var tipuesearch = {"pages":[{"text":"FIAT FIAT: Fortran Implementation of Abstract Types This library aims to implement various common data structures\nin Fortran.\nThese will be implemented in a generic manner using a container type. This\nwas originally developed in PolyCon ,\nbut has since been folded into FIAT, with some improvements. See the\nwiki for a list of data structures which are to be implemented and information\nfor those wishing to contribute. Also take a look at the API documentation for a detailed description of the methods which will be supported. License FIAT is licensed under the GNU Lesser General Public License (LGPL) v3.0 or\nlater. The terms are provided in the file LICENSE . The LGPL make reference\nto the GNU General Public License (GPL), which is provided in the file GPL .\nIn brief, the LGPL allows this library to be linked to software under any\nlicense (with a few, minor, restrictions). However, should a modified version\nof the library itself be released, it must be licensed under the terms of\nthe LGPL or GPL. Developer Info Chris MacMackin I am a graduate student at the University of Oxford, studying the melting and evolution of ice shelves. I enjoy programming, with my favourite languages being Fortran (for numerical work), Vala (for object-oriented programming and anything involving a GUI), and Python (for scripting and everything else).","tags":"","loc":"index.html","title":" FIAT "},{"text":"Source Code ! !  abstract_container_mod.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module abstract_container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: LGPLv3 !! !! Provides an abstract container derived type which can be used !! as a sort of unlimited polymorphic entity whose contents are !! retrievable with type-guards. Different subclasses are created !! in order to hold different data-types. See [[container]] for !! instructions on creating concrete subclasses. See [[container_mod]] !! for subclasses containing the built-in data-types. use iso_fortran_env , only : stderr => error_unit , i1 => int8 implicit none private type , public , abstract :: container !! Author: Chris MacMackin !! Date: December 2015 !! Display: Public !!          Private !! !! An abstract derived type which contains data. This type can be !! used for a sort of unlimited polymorphism. It is extended to !! create different classes capable of holding particular !! data-types. Extensions must implement the procedure !! [[container:typeguard]] in order to provide the ability to !! transfer data out of the container and into a variable. Assuming !! that you are creating a concrete class called !! `example_container`, this should be implemented as follows: !! !!```fortran !! module example_container_mod !! !!   use abstract_container_mod !!   implicit none !!   private !! !!   type example !!     integer, public :: i !!   end type example !! !!   type, extends(container) :: example_container !!   contains !!     private !!     procedure :: typeguard => example_guard !!   end type example_container !! !! contains !! !!   logical function example_guard(this, lhs) result(ret) !!     class(example_container), intent(in) :: this !!     class(*), intent(inout) :: lhs !!     select type(lhs) !!       type is(example) !!         lhs = transfer(this%contents(), lhs) !!         ret = .true. !!       class default !!         ret = .false. !!     end select !!   end function example_guard !! !! end module example_container_mod !!``` private integer ( i1 ), dimension (:), allocatable :: storage !! Variable in which to place data contents logical :: filled = . false . !! `.true.` if container is set, `.false.` otherwise contains private procedure ( guard ), deferred :: typeguard !! Performs the actual transfer of the container's contents to !! another variable. procedure , public :: contents !! Retrieves the contents of the container, in the form of an !! integer array. procedure , public :: is_filled !! Returns whether contents have been assigned to the container procedure , public :: set !! Sets the contents of the container. procedure , pass ( rhs ) :: assign_container !! Assigns container contents to another variable. procedure :: is_equal !! Check whether two containers have the same contents. generic , public :: assignment ( = ) => assign_container generic , public :: operator ( == ) => is_equal end type container abstract interface logical function guard ( this , lhs ) import container class ( container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs !! The variable which the container contents are to be !! transferred to. end function guard pure function test_func ( item ) !* An abstract interface for a function which tests a !  [[container]] object in some way import :: container class ( container ), intent ( in ) :: item !! The item which is being evaluated logical :: test_func !! Whether the item passes the test or not end function test_func pure function addition_func ( item1 , item2 ) !* Performs an addition operation on two [[container]] objects, !  returning the result in a container. import :: container class ( container ), intent ( in ) :: item1 !! One of the items in the addition class ( container ), intent ( in ) :: item2 !! The other item in the addition class ( container ), allocatable :: addition_func !! The sum, `item1 + item2` end function addition_func pure function subtraction_func ( item1 , item2 ) !! An abstract interface for a procedure finding the difference !! between two items, `item1 - item2`. Note that a procedure may !! satisfy both this abstract interface and [[comparison_func]]. import :: container class ( container ), intent ( in ) :: item1 !! The item which the other is subtracted from class ( container ), intent ( in ) :: item2 !! The item subtracted from the other real :: subtraction_func !! A real number, the absolute value of which represents the !! magnitude of the difference between `item1` and `item2`. end function subtraction_func pure function comparison_func ( item1 , item2 ) !* An abstract interface for a procedure comparing two !  [[container]] objects. Note that a procedure may satisfy both !! this abstract interface and [[subtraction_func]]. import :: container class ( container ), intent ( in ) :: item1 !! The first item in the comparison class ( container ), intent ( in ) :: item2 !! The second item in the comparison real :: comparison_func !! negative if `item1 < item2`, 0 if `item1 == item2`, positive !! if `item1 > item2` end function comparison_func subroutine action_sub ( item ) !* An abstract interface for a procedure which will act on each !  item in a list. import :: container class ( container ), intent ( inout ) :: item !! A container object which is will be modified in some way end subroutine action_sub end interface public :: test_func , addition_func , subtraction_func , & comparison_func , action_sub contains subroutine assign_container ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the contents of the container to another variable. !! If the other variable is another container of the same type !! then the contents will be transferred. If the other variable is !! the same type as the contents of the container (as determined !! by the [[container:typeguard]] routine provided for that !! concrete type extension) then it will be given the value held by !! the container. Otherwise, an error message will be printed and !! the program stopped. If compiled with `gfortran` then a backtrace !! will also be printed. In the event that the container was never !! set to a value, then this also constitutes an error. class ( * ), intent ( inout ) :: lhs !! The variable which the container contents will be assigned to. class ( container ), intent ( in ) :: rhs !! The container variable. !------------------------------------------------------------------- select type ( lhs ) class is ( container ) if ( same_type_as ( lhs , rhs )) then if ( rhs % filled ) then lhs % storage = rhs % storage lhs % filled = . true . else if ( lhs % filled ) then deallocate ( lhs % storage ) lhs % filled = . false . end if return else write ( stderr , * ) \"ERROR: Can not assign to a different container subclass\" #ifdef __GFORTRAN__ call backtrace #endif stop end if class default if ( rhs % filled ) then if ( rhs % typeguard ( lhs )) return write ( stderr , * ) \"ERROR: Can not assign this container's contents to given variable\" #ifdef __GFORTRAN__ call backtrace #endif stop else write ( stderr , * ) \"ERROR: Container is empty.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end select end subroutine assign_container pure function contents ( this ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Returns the contents, encoded as a character array, of the !! container. class ( container ), intent ( in ) :: this integer ( i1 ), dimension (:), allocatable :: contents contents = this % storage end function contents elemental logical function is_filled ( this ) !! Author: Chris MacMackin !! Date: March 2016 !! !! Returns `.true.` if a value has been assigned to the container, !! `.false.` otherwise. class ( container ), intent ( in ) :: this is_filled = this % filled end function is_filled subroutine set ( this , content ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Sets the contents of the storage array to value passed. The type !! of the variable provided must be the same as the container !! variable is designed to accept (as determined by the !! concrete type implementation of the [[container:typeguard]] !! method in the extension) or be of the same type of container. !! Otherwise an error message will be printed and the program will !! exit. If `gfortran` was used to compile then a backtrace will !! also be printed. !! !! @Warning During the initial phase of writing unit tests for the !! containers, I found that when content is class(container) then !! ~5GB of memory would end up being allocated when allocating tmp. !! After various experiments, I found that changing where tmp is !! allocated, so that this is only done if it is not being allocated !! to another container type, stopped this from happening. However, !! I'm still not clear on exactly what the cause of the bug is !! (similar things occasionally happened when DEallocating a !! container) and suspect its origin is a compiler bug. As such, I'm !! keeping this note here for information in case the issue ever !! arises again. !! class ( container ), intent ( out ) :: this class ( * ), intent ( in ) :: content !! The value to be placed in the container class ( * ), allocatable :: tmp if (. not . allocated ( this % storage )) allocate ( this % storage ( 1 )) if ( same_type_as ( this , content )) then select type ( content ) class is ( container ) if ( content % filled ) then this % filled = . true . this % storage = content % storage else this % filled = . false . deallocate ( this % storage ) endif return end select end if allocate ( tmp , source = content ) if ( this % typeguard ( tmp )) then this % filled = . true . this % storage = transfer ( content , this % storage ) else write ( stderr , * ) \"ERROR: Can not assign given variable to this container\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end subroutine set elemental logical function is_equal ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Checks whether two containers are of the same type and are !! storing the same contents. class ( container ), intent ( in ) :: lhs , rhs if (. not . same_type_as ( lhs , rhs )) then is_equal = . false . return end if if ((. not . lhs % filled ). and .(. not . rhs % filled )) then is_equal = . true . return end if if ( lhs % filled . neqv . rhs % filled ) then is_equal = . false . return end if is_equal = ( size ( lhs % storage ) == size ( rhs % storage ) . and . & all ( lhs % storage == rhs % storage )) end function is_equal end module abstract_container_mod","tags":"","loc":"sourcefile/abstract_container.f90.html","title":"abstract_container.F90 – FIAT"},{"text":"Source Code ! !  array_list.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module array_list_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides a concrete implementation of the [[list]] abstract data ! type. This implementation, the [[array_list]], stores values in an ! array and thus fast to read from. ! use list_mod , only : list use abstract_container_mod , only : container , test_func , & addition_func , subtraction_func , & comparison_func , action_sub use iterator_mod , only : iterator use ordered_mod , only : ordered implicit none private type , public , extends ( list ) :: array_list !* Author: Chris MacMackin !  Date: March 2016 ! ! A concrete implementation of the [[list]] abstract data type. ! This implementation stores list contents in an array. It is fast ! to read from, but it is slow to insert elements into the middle ! of the list or to add new items to the end (if doing so requires ! the storage array to be expanded). ! ! Note that this list is 1-indexed and that all slices are ! inclusive. In this regard, they are similar to arrays and strings ! in Fortran. ! private class ( container ), allocatable , dimension (:) :: contents integer :: length contains procedure :: iter => array_list_iter procedure :: contents_type => array_list_contents_type procedure :: size => array_list_size procedure :: push => array_list_push procedure :: pop => array_list_pop procedure :: peek => array_list_peek procedure , private :: concat => array_list_concat procedure :: clear => array_list_clear procedure :: pushleft => array_list_push procedure :: pushright => array_list_append procedure :: popleft => array_list_popleft procedure :: popright => array_list_pop procedure :: peekleft => array_list_peekleft procedure :: peekright => array_list_peek procedure :: append => array_list_append procedure :: get => array_list_get procedure , private :: set_single => array_list_set_single procedure , private :: set_multiple => array_list_set_multiple procedure :: get_index => array_list_get_index procedure :: get_last_index => array_list_get_last_index procedure :: get_indices => array_list_get_indices procedure :: slice => array_list_slice procedure :: foreach => array_list_foreach procedure :: insert => array_list_insert procedure :: remove => array_list_remove procedure :: remove_last => array_list_remove_last procedure :: remove_all => array_list_remove_all procedure , private :: delete_single => array_list_delete_single procedure , private :: delete_multiple => array_list_delete_multiple procedure , private :: delete_slice => array_list_delete_slice procedure :: has => array_list_has procedure :: sort => array_list_sort procedure :: min => array_list_min procedure :: max => array_list_max procedure :: nearest => array_list_nearest procedure :: sum => array_list_sum procedure :: filter => array_list_filter procedure :: to_array => array_list_to_array end type array_list contains pure type ( iterator ) function array_list_iter ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an [[iterator]] containing the contents of this list ! as they were at the time this method was called. ! class ( array_list ), intent ( in ) :: this end function array_list_iter pure function array_list_contents_type ( this ) result ( cont ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a container with the dynamic type of the contents of this ! list. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: cont end function array_list_contents_type pure integer function array_list_size ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the number of items in the list ! class ( array_list ), intent ( in ) :: this end function array_list_size pure subroutine array_list_push ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Adds an item to the beginning of the list. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! The value to place at the start of the list. end subroutine array_list_push function array_list_pop ( this ) result ( pop ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the item at the end of the list and returns it. ! class ( array_list ), intent ( inout ) :: this class ( container ), allocatable :: pop !! The value from the end of the list end function array_list_pop pure function array_list_peek ( this ) result ( peek ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the end of the list, without removing it. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: peek !! The element at the end of the list end function array_list_peek pure function array_list_concat ( lhs , rhs ) result ( concat ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Join this list with an [[ordered]] object, returning the result. The ! contents of the returned object are ordered such that applying ! [[ordered:pop]] until it is empty would return items in the same order as ! calling [[ordered:pop]] until the list is empty and then until the second ! object is empty. ! class ( array_list ), intent ( in ) :: lhs !! The list class ( ordered ), intent ( in ) :: rhs !! The object being concatenated to the list class ( ordered ), allocatable :: concat !! The concatenated object. Will have dynamic type [[array_list]]. end function array_list_concat pure subroutine array_list_clear ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes all items from this list, but does not change its container type. ! class ( array_list ), intent ( inout ) :: this end subroutine array_list_clear function array_list_popleft ( this ) result ( pop ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the item at the start of the list and returns it. ! class ( array_list ), intent ( inout ) :: this class ( container ), allocatable :: pop !! The item just removed from the start of the list end function array_list_popleft pure function array_list_peekleft ( this ) result ( peek ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the start of the list. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: peek !! The item at the start of the list end function array_list_peekleft pure subroutine array_list_append ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Adds the provided item to the end of the list. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! Item to be appended to list end subroutine array_list_append pure function array_list_get ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the specified location in the list. Returns ! an unallocated container if that location has not been set. ! class ( array_list ), intent ( in ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element to return class ( container ), allocatable :: array_list_get !! The item with index `element`. Unallocated if no such element !! is present. end function array_list_get subroutine array_list_set_single ( this , element , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the value of the provided element in the specified location ! in the array. Crashes if this element is not already defined. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element whose value is to be set. class ( * ), intent ( in ) :: item !! The value to store in the specified element end subroutine array_list_set_single subroutine array_list_set_multiple ( this , elements , items ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the values of the provided array of items in the locations ! specified by the corresponding indices in the in the array of ! elements. ! class ( array_list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: elements !! The indices (starting from 1) of the elements whose values !! are to be set. class ( * ), dimension (:), intent ( in ) :: items !! The values to be stored in the specified elements. Each item !! is placed in the element specified by the integer in the !! corresponding position in the array `elements`. end subroutine array_list_set_multiple pure function array_list_get_index ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the index of the first occurrence of the item in the list. ! If there are no occurrences, then returns -1. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: array_list_get_index !! Position of the first occurrence of `item` in list end function array_list_get_index pure function array_list_get_last_index ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the index of the last occurrence of the item in the list. ! If there are no occurrences, then returns -1. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: array_list_get_last_index !! Position of the last occurrence of `item` in list. -1 if `item` !! not present end function array_list_get_last_index pure function array_list_get_indices ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an array containing the indices of all occurrences of the ! item in the list. If there are no occurrences, then returns an ! unallocated array. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer , dimension (:), allocatable :: array_list_get_indices !! Positions of the all occurrences of `item` in list. Unallocated !! if `item` not present. end function array_list_get_indices function array_list_slice ( this , start_element , end_element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an [[array_list]] instance containing all items in this ! list within the specified slice, inclusive. Crashes if one of ! the indices is outside of the list's bounds. ! class ( array_list ), intent ( in ) :: this integer , intent ( in ) :: start_element !! The index of the first element in the slice to be returned integer , intent ( in ) :: end_element !! The index of the last element in the slice to be returned class ( list ), allocatable :: array_list_slice !! An array_list containing the elements within the slice. end function array_list_slice subroutine array_list_foreach ( this , action ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Performs the specified action on each item in the list, in place. ! class ( array_list ), intent ( inout ) :: this procedure ( action_sub ) :: action !! A procedure to act on each element of the list end subroutine array_list_foreach subroutine array_list_insert ( this , position , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the provided item into the list at the position specified, ! moving all succeeding items forward by one. The position must be ! one which is already filled or the length of the list plus one. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: position !! The location at which the new element will be placed class ( * ), intent ( in ) :: item !! The value to be placed in the list end subroutine array_list_insert subroutine array_list_remove ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove the first occurrence of the specified item from the list, ! moving all succeeding items back by one position. No action is ! taken if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the first occurrence of which will be removed from !! the list end subroutine array_list_remove subroutine array_list_remove_last ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove the last occurrence of the specified item from the list, ! moving all succeeding items back by one position. No action is ! taken if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the last occurrence of which will be removed from !! the list end subroutine array_list_remove_last subroutine array_list_remove_all ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove all occurrences of the specified item from the list, ! moving all succeeding items back in position. No action is taken ! if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, all occurrences of which will be removed from the !! list end subroutine array_list_remove_all subroutine array_list_delete_single ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the element at the specified position in the list, moving ! all succeeding items back by one position. Crashes if the element ! has not been set. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The position of the element to be deleted from the list end subroutine array_list_delete_single subroutine array_list_delete_multiple ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the elements at the positions specified by the indices in ! the array `elements` from the list. The elements removed are those ! at the specified location just before the call was made. Once all ! removals have been performed, the remaining elements well be moved ! backwards in position as necessary. Crashes if an element has not ! been set. ! class ( array_list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: element !! The positions of the elements to be deleted from the list end subroutine array_list_delete_multiple subroutine array_list_delete_slice ( this , start_element , end_element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the element within the specified slice of the list, moving ! all succeeding items back by the number of items deleted. The ! slice contains the element at the start index to the end index, ! inclusive. Crashes if part of the slice has not been set. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: start_element !! Index of the first element in the slice to be deleted integer , intent ( in ) :: end_element !! Index of the last element in the slice to be deleted end subroutine array_list_delete_slice elemental function array_list_has ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Indicates whether there are any copies of the specified item ! present in the list. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! A value whose presence in the list is being checked for logical :: array_list_has !! `.true.` if `item` is present in list, `.false.` otherwise end function array_list_has subroutine array_list_sort ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Sorts the list, in place, so that all items are in ascending order ! according the the provided comparison function. ! class ( array_list ), intent ( inout ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another end subroutine array_list_sort pure function array_list_min ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the smallest item contained in the list, as determined ! using the provided comparison function. ! class ( array_list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: array_list_min !! The smallest item in the list, as determined by the !! `comparison` function end function array_list_min pure function array_list_max ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the largest item contained in the list, as determined ! using the provided comparison function. ! class ( array_list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: array_list_max !! The largest item in the list, as determined by the !! `comparison` function end function array_list_max pure function array_list_nearest ( this , item , subtraction ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the value contained in the list for which the subtraction ! function returns the smallest absolute real number when comparing ! with the specified `item`. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! The value which those in the list are being compared to procedure ( subtraction_func ) :: subtraction !! A function determining the magnitude of the difference !! between two items class ( container ), allocatable :: array_list_nearest !! The value from the list which, when passed to `subtraction` !! with `item` as the other argument, returns the smallest value end function array_list_nearest pure function array_list_sum ( this , addition ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a [[container]] representing the sum of all items ! contained in the list. This sum is calculated by repeatedly ! applying the addition procedure to the list's contents. ! class ( array_list ), intent ( in ) :: this procedure ( addition_func ) :: addition !! A procedure performing addition between two [[container]] !! objects and returning the result in another container class ( container ), allocatable :: array_list_sum !! A container holding the sum of all of the items held within !! this list end function array_list_sum pure function array_list_filter ( this , test ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a new list containing only those items held in this list ! which pass the provided test. ! class ( array_list ), intent ( in ) :: this procedure ( test_func ) :: test !! A test for which the values that pass will be returned in a !! new list class ( list ), allocatable :: array_list_filter !! Contains those items in this list for which `test` returns !! `.true.` end function array_list_filter pure function array_list_to_array ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns copies of all items held in this list, stored within an ! array of [[container]] objects. ! class ( array_list ), intent ( in ) :: this class ( container ), dimension (:), allocatable :: array_list_to_array !! An array of [[container]] objects holding the contents of !! this list end function array_list_to_array end module array_list_mod","tags":"","loc":"sourcefile/array_list.f90.html","title":"array_list.f90 – FIAT"},{"text":"Source Code ! !  bidir_node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module bidir_node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Implements a node which contains a pointer to two other (the next ! and previous) nodes, allowing a chain to be formed. This can be used ! to, for example, build a doubly-linked lists. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. ! use linked_node_mod , only : linked_node implicit none private type , extends ( linked_node ), public :: bidir_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at two other ! (the previous and next) bidir_node objects or objects of a ! descendent type. This type can be built up into a chain, allowing ! a doubly-linked list to be formed. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( bidir_node ), pointer :: prev => null () contains procedure :: has_prev procedure :: get_prev procedure :: set_prev procedure :: unset_prev end type bidir_node contains elemental logical function has_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points to a previous one, forming ! a chain in the backwards direction. ! class ( bidir_node ), intent ( in ) :: this has_prev = associated ( this % prev ) end function has_prev function get_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the previous node in the chain. If this node ! does not point at a previous one one, then a null pointer is ! returned. ! class ( bidir_node ), intent ( in ) :: this class ( bidir_node ), pointer :: get_prev if ( this % has_prev ()) then get_prev => this % prev else get_prev => null () end if end function get_prev subroutine set_prev ( this , new_prev , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the pointer to the previous node in the chain. If this node ! already points to a previous one, the pointer will, by default, be ! nullified. This may result in a memory leak. Optionally, by ! setting `deallocate_old=.true.`, the previous node (and all nodes ! it points to) can be deallocated. This may result in a segfault if ! another part of the program tries to access the former previous ! node. The new previous node will not automatically be set to have ! this one as the next, with the same rules applied to deallocation. ! class ( bidir_node ), intent ( inout ) :: this class ( bidir_node ), pointer , intent ( in ) :: new_prev !! The node which will now be previous in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! previous nodes in the chain. Defaults to `.false.`. call this % unset_prev ( deallocate_old ) this % prev => new_prev end subroutine set_prev subroutine unset_prev ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the previous node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! previous node (and all previous nodes it points to) can be ! deallocated. This may result in a segfault if another part of the ! program tries to access the former previous node. ! class ( bidir_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! p nodes in the chain. Defaults to `.false.`. if (. not . this % has_prev ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % prev % unset_prev (. true .) deallocate ( this % prev ) return end if end if nullify ( this % prev ) end subroutine unset_prev end module bidir_node_mod","tags":"","loc":"sourcefile/bidir_node.f90.html","title":"bidir_node.f90 – FIAT"},{"text":"Source Code !  container_mod.f90 ! !  Copyright 2015 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! ! module container_mod !! Author: Chris MacMackin !! Date: December 2015 !! License: LGPLv3 !! !! Provides implementations of the [[container]] abstract !! derived type for all of the intrinsic variable types. use abstract_container_mod , only : container use iso_fortran_env , only : i1 => int8 , i2 => int16 , i4 => int32 , & i8 => int64 , r4 => real32 , r8 => real64 , & r16 => real128 implicit none private type , extends ( container ) :: int_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt integer type. contains private procedure :: typeguard => int_guard end type int_container type , extends ( container ) :: int1_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 1 byte integer type. contains private procedure :: typeguard => int1_guard end type int1_container type , extends ( container ) :: int2_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 2 byte integer type. contains private procedure :: typeguard => int2_guard end type int2_container type , extends ( container ) :: int4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte integer type. contains private procedure :: typeguard => int4_guard end type int4_container type , extends ( container ) :: int8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte integer type. contains private procedure :: typeguard => int8_guard end type int8_container type , extends ( container ) :: real_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt real type. contains private procedure :: typeguard => real_guard end type real_container type , extends ( container ) :: real4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte real type. contains private procedure :: typeguard => real4_guard end type real4_container type , extends ( container ) :: real8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte real type. contains private procedure :: typeguard => real8_guard end type real8_container type , extends ( container ) :: real16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte real type. contains private procedure :: typeguard => real16_guard end type real16_container type , extends ( container ) :: complex_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt complex type. contains private procedure :: typeguard => complex_guard end type complex_container type , extends ( container ) :: complex4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte complex type. contains private procedure :: typeguard => complex4_guard end type complex4_container type , extends ( container ) :: complex8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte complex type. contains private procedure :: typeguard => complex8_guard end type complex8_container type , extends ( container ) :: complex16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte complex type. contains private procedure :: typeguard => complex16_guard end type complex16_container type , extends ( container ) :: logical_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt logical type. contains private procedure :: typeguard => logical_guard end type logical_container type , extends ( container ) :: character_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt character type. contains private procedure :: typeguard => character_guard end type character_container public :: character_container , complex_container , complex4_container , & complex8_container , complex16_container , int_container , & int1_container , int2_container , int4_container , & int8_container , logical_container , real_container , & real4_container , real8_container , real16_container contains logical function int_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int_guard logical function int1_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int1_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i1 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int1_guard logical function int2_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int2_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i2 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int2_guard logical function int4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int4_guard logical function int8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int8_guard logical function real_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real_guard logical function real4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real4_guard logical function real8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real8_guard logical function real16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real16_guard logical function complex_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex_guard logical function complex4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex4_guard logical function complex8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex8_guard logical function complex16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex16_guard logical function logical_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( logical_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( logical ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function logical_guard logical function character_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( character_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( character ( len =* )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function character_guard end module container_mod","tags":"","loc":"sourcefile/container.f90.html","title":"container.f90 – FIAT"},{"text":"Source Code ! !  countable.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module countable_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides the [[countable]] abstract type. For a type to be ! countable, the number of individual pieces of data stored within ! must be known in advance. ! use iterable_mod , only : iterable implicit none private type , extends ( iterable ), abstract , public :: countable !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! An abstract data type which can be iterated, for which the number of ! pieces of items of data stored within is known. ! contains procedure ( size_func ), deferred :: size !! Return the number of items stored within this object end type countable abstract interface pure function size_func ( this ) import :: countable class ( countable ), intent ( in ) :: this integer :: size_func !! The number of items stored in this object. end function size_func end interface end module countable_mod","tags":"","loc":"sourcefile/countable.f90.html","title":"countable.f90 – FIAT"},{"text":"Source Code ! !  data_set.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module data_set_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for the set data structure. Such sets ! support similar operations to their mathematical counterparts. ! This class, and its descendents, have a comparable set of methods ! to those in the Python ! [frozenset](https://docs.python.org/2/library/stdtypes.html#frozenset) ! type. ! use abstract_container_mod , only : container , test_func , & addition_func , subtraction_func , & comparison_func , action_sub use countable_mod , only : countable use array_list_mod , only : array_list implicit none private type , public , extends ( countable ), abstract :: data_set !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for set data structures. These sets support a ! similar selection of operations as do their mathematical ! counterparts. The collection of methods for this type waas inspired ! by those available for the ! [frozenset](https://docs.python.org/2/library/stdtypes.html#frozenset) ! type in Python. ! contains procedure ( union_func ), deferred :: union !! Returns a set containing the items held in this set and the !! passed set. generic :: operator ( + ) => union !! Returns the union of the two sets procedure ( intersect_func ), deferred :: intersection !! Returns a set containing only the items present in both this !! set and the argument procedure ( diff_func ), deferred :: difference !! Returns a set containing the item present in this set but not !! present in the argument generic :: operator ( - ) => difference !! Returns the difference between the two sets procedure ( pure_diff_func ), deferred :: symmetric_difference !! Returns a set containing those items present either only in !! this set or only in the argument procedure ( relation_func ), deferred :: is_disjoint !! True if none of the items in this set are present in the !! argument procedure ( relation_func ), deferred :: is_subset !! True if every element in this set is also in the argument procedure ( relation_func ), deferred :: is_proper_subset !! True if every element in this set is also in the argument and !! this set is not equal to the argument procedure ( relation_func ), deferred :: is_superset !! True if every element in the argument is also present in this !! set. procedure ( relation_func ), deferred :: is_proper_superset !! True if every element in the argument is also present in this !! set and the argument is not equal to this set. procedure ( relation_func ), deferred :: is_equal !! True if this set and the argument contain only the same items. generic :: operator ( <= ) => is_subset !! True if every element in this set is also in the argument generic :: operator ( < ) => is_proper_subset !! True if every element in this set is also in the argument and !! this set is not equal to the argument generic :: operator ( >= ) => is_superset !! True if every element in the argument is also present in this !! set. generic :: operator ( > ) => is_proper_superset !! True if every element in the argument is also present in this !! set and the argument is not equal to this set. generic :: operator ( == ) => is_equal !! True if this set and the argument contain only the same items. procedure ( has_func ), deferred :: has !! True if the argument is present in the set procedure ( empty_func ), deferred :: is_empty !! True if the set contains no items procedure ( peek_func ), deferred :: peek !! Returns an item, at random, from the set procedure ( filter_func ), deferred :: filter !! Returns a set containing all elements from this set for which !! the provided test procedure returns `.true.` procedure ( enum_func ), deferred :: enumerate !! Returns an [array_list] containing all of the items present !! in this set. procedure ( min_func ), deferred :: min !! Returns the smallest item in the set as determined using the !! provided comparison procedure procedure ( max_func ), deferred :: max !! Returns the largest item in the set as determined using the !! provided comparison procedure procedure ( nearest_func ), deferred :: nearest !! Returns the item in the set for which the provided subtraction !! procedure returns the smallest absolute value procedure ( sum_func ), deferred :: sum !! Returns an item representing the sum as determined by !! iteratively applying the provided addition procedure to all !! items in the set end type data_set abstract interface pure function union_func ( this , other ) import :: data_set class ( data_set ), intent ( in ) :: this , other !! A second set class ( data_set ), allocatable :: union_func !! A set containing all elements found in this one and the other end function union_func pure function intersect_func ( this , other ) import :: data_set class ( data_set ), intent ( in ) :: this , other !! A second set class ( data_set ), allocatable :: union_func !! A set containing all elements found both in this one and !! the other end function intersect_func pure function diff_func ( this , other ) import :: data_set class ( data_set ), intent ( in ) :: this , other !! A second set class ( data_set ), allocatable :: diff_func !! A set containing elements found in this one and not the other end function diff_func pure function pure_diff_func ( this , other ) import :: data_set class ( data_set ), intent ( in ) :: this , other !! A second set class ( data_set ), allocatable :: pure_diff_func !! A set containing elements found in one, but not both, of this !! set or the other set end function pure_diff_func pure function relation_func ( this , other ) import :: data_set class ( data_set ), intent ( in ) :: this , other !! A second set logical :: relation_func !! Whether the relationship between `this` and `other` is true end function relation_func pure function has_func ( this , item ) import :: data_set class ( data_set ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! An item which may be contained in the set logical :: has_func !! Whether `item` is present in this set end function has_func pure function empty_func ( this ) import :: data_set class ( data_set ), intent ( in ) :: this logical :: empty_func !! `.true.` if this set contains no items end function empty_func pure function peek_func ( this ) import :: data_set import :: container class ( data_set ), intent ( in ) :: this class ( container ), allocatable :: peek_func !! An item contained within the set. Is unallocated if the set !! is empty. end function peek_func pure function filter_func ( this , test ) import :: data_set import :: test_func class ( data_set ), intent ( in ) :: this procedure ( test_func ) :: test !! A test for which the values that pass will be returned in a !! new list class ( data_set ), allocatable :: filter_func !! Contains those items in this set for which `test` returns !! `.true.` end function filter_func pure function enum_func ( this ) import :: data_set import :: array_list class ( data_set ), intent ( in ) :: this type ( array_list ) :: enum_func !! A list containing copies of all of the items in this set end function enum_func pure function min_func ( this , comparison ) import :: data_set import :: comparison_func import :: container class ( data_set ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: min_func !! The smallest item in the set, as determined by the !! `comparison` function end function min_func pure function max_func ( this , comparison ) import :: data_set import :: comparison_func import :: container class ( data_set ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: max_func !! The largest item in the set, as determined by the !! `comparison` function end function max_func pure function nearest_func ( this , item , subtraction ) import :: data_set import :: container import :: subtraction_func class ( data_set ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! The value which those in the set are being compared to procedure ( subtraction_func ) :: subtraction !! A function determining the magnitude of the difference !! between two items class ( container ), allocatable :: nearest_func !! The value from the set which, when passed to `subtraction` !! with `item` as the other argument, returns the smallest value end function nearest_func pure function sum_func ( this , addition ) import :: data_set import :: container import :: addition_func class ( data_set ), intent ( in ) :: this procedure ( addition_func ) :: addition !! A procedure performing addition between two [[container]] !! objects and returning the result in another container class ( container ), allocatable :: sum_func !! A container holding the sum of all of the items held within !! this set end function sum_func end interface end module data_set_mod","tags":"","loc":"sourcefile/data_set.f90.html","title":"data_set.f90 – FIAT"},{"text":"Source Code ! !  dequeue.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module deque_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides a doubled ended queue abstract data type. This is a first ! in first out data structure which can be added to or taken from at ! either end. ! use queue_mod , only : queue use abstract_container_mod , only : container implicit none private type , abstract , extends ( queue ), public :: deque !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type representing the double ended queue data ! structure. Rather than just pushing items to one end (the \"left ! end\") and popping them from the other (the \"right end\"), items can ! be pushed or popped to/from either the right or the left. ! contains procedure ( push_sub ), deferred :: pushleft !! Add an item to the left end of the data structure (equivalent !! to [[ordered:push]] on a queue) procedure ( push_sub ), deferred :: pushright !! Add an item to the right end of the data structure procedure ( pop_func ), deferred :: popleft !! Remove and return the item from the left end of the data !! structure procedure ( pop_func ), deferred :: popright !! Remove and return the item from the right end of the data !! structure (equivalent to [[ordered:pop]] on a queue) procedure ( peek_func ), deferred :: peekleft !! Return, but do not remove, the item at the left end of the data !! structure procedure ( peek_func ), deferred :: peekright !! Return, but do not remove, the item at the left end of the data !! structure (equivalent to [[ordered:peek]] on a queue) end type deque abstract interface pure subroutine push_sub ( this , item ) import :: deque class ( deque ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! The value to be added to the list end subroutine push_sub function pop_func ( this ) import :: deque import :: container class ( deque ), intent ( inout ) :: this class ( container ), allocatable :: pop_func !! The next value, which has just been removed end function pop_func pure function peek_func ( this ) import :: deque import :: container class ( deque ), intent ( in ) :: this class ( container ), allocatable :: peek_func !! The next value, which is not removed end function peek_func end interface end module deque_mod","tags":"","loc":"sourcefile/deque.f90.html","title":"deque.f90 – FIAT"},{"text":"Source Code ! !  dictionary.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module dictionary_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for mapping data structures. These are ! data structures which consist of key-value pairs. ! use abstract_container_mod , only : container use data_set_mod , only : data_set use array_list_mod , only : array_list implicit none private type , public , extends ( data_set ), abstract :: dictionary !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for mapping data structures. These are data ! structures which consist of key-value pairs. Examples of such ! structures are ! [dictionaries](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) ! in Python or a ! [hash](https://en.wikibooks.org/wiki/Perl_Programming/Hash_Variables) ! variable in Perl. ! contains procedure ( keys_func ), deferred :: keys !! Returns a list of the keys in this dictionary procedure ( values_func ), deferred :: values !! Returns a list of the values stored in this dictionary, in the !! same order as the corresponding keys are returned when !! [[dictionary:keys]] is called procedure ( set_func ), deferred :: set !! Sets the given key to the give value procedure ( type_func ), deferred :: key_type !! Returns a [[container]] of the dynamics type used to store keys procedure ( type_func ), deferred :: value_type !! Returns a [[container]] of dynamics the type used to store !! values end type dictionary abstract interface pure function keys_func ( this ) import :: dictionary import :: array_list class ( dictionary ), intent ( in ) :: this type ( array_list ) :: keys_func !! A list containing all of the keys in this dictionary end function keys_func pure function values_func ( this ) import :: dictionary import :: array_list class ( dictionary ), intent ( in ) :: this type ( array_list ) :: values_func !! A list containing all of the values in this dictionary, !! stored in the same order as their corresponding key would !! be were [[dictionary:keys]] called end function values_func function set_func ( this , key , val ) import :: dictionary class ( dictionary ), intent ( inout ) :: this class ( * ), intent ( in ) :: key !! The key whose value is to be set class ( * ), intent ( in ) :: val !! The value to be assigned to the specified key end function set_func pure function type_func ( this ) import :: dictionary import :: container class ( dictionary ), intent ( in ) :: this class ( container ), allocatable :: type_func !! A container of the dynamic type used to store this !! dictionary's keys or values. end function type_func end interface end module dictionary_mod","tags":"","loc":"sourcefile/dictionary.f90.html","title":"dictionary.f90 – FIAT"},{"text":"Source Code ! !  dynamic_set.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module dynamic_set_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a dynamic set data structures. This ! data structure is similar to a normal [[data_set]] structure, but ! new items can be added to the set. It is similar to the ! [set](https://docs.python.org/2/library/stdtypes.html#set) type in ! Python. ! use abstract_container_mod , only : container use iterable_mod , only : iterable use data_set_mod , only : data_set type , public , abstract , extends ( data_set ) :: dynamic_set !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type for dynamic sets. These are much like ! mathematical sets, but differ from the parent [[data_set]] type ! in that items can be added to or removed from the set. To ! accomplish this, various additional methods are available. This ! data type is similar to the ! [set](https://docs.python.org/2/library/stdtypes.html#set) type in ! Python. ! contains procedure ( single_sub ), deferred , private :: add_single !! Places the item in the set, if not already present procedure ( multiple_sub ), deferred , private :: add_multiple !! Places each item in the array into the set, if not already !! present generic :: add => add_single , add_multiple procedure ( iter_sub ), deferred :: add_iter !! Places each item in the iterable into the set, if not already !! present. procedure ( single_sub ), deferred , private :: remove_single !! Removes the item from the set, if present procedure ( multiple_sub ), deferred , private :: remove_multiple !! Removes each item in the array from the set, if present generic :: remove => remove_single , remove_multiple procedure ( iter_sub ), deferred :: remove_iter !! Removes each item in the iterable from the set, if present procedure ( pop_func ), deferred :: pop !! Removes a random item from the set and returns it procedure ( clear_sub ), deferred :: clear !! Removes all items from the set end type dynamic_set abstract interface pure subroutine single_sub ( this , item ) import :: dynamic_set class ( dynamic_set ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item to add or remove from the set end subroutine single_sub pure subroutine multiple_sub ( this , items ) import :: dynamic_set class ( dynamic_set ), intent ( inout ) :: this #ifdef __GFORTRAN__ class ( * ), dimension (:), intent ( in ) :: items #else class ( * ), dimension ( * ), intent ( in ) :: items #endif !! An array containing items to add or remove from the set end subroutine multiple_sub pure subroutine iter_sub ( this , items ) import :: dynamic_set import :: iterable class ( dynamic_set ), intent ( inout ) :: this class ( iterable ), intent ( in ) :: items !! An iterable containing items to add or remove from the set end subroutine iter_sub function pop_func ( this ) import :: dynamic_set import :: container class ( dynamic_set ), intent ( inout ) :: this class ( container ), allocatable :: pop_func !! A random item which has been removed from the set end function pop_func pure subroutine clear_sub ( this ) import :: dynamic_set class ( dynamic_set ), intent ( inout ) :: this end subroutine clear_sub end interface end module dynamic_set_mod","tags":"","loc":"sourcefile/dynamic_set.f90.html","title":"dynamic_set.F90 – FIAT"},{"text":"Source Code ! !  iteratable.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module iterable_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides the [[iterable]] abstract type. All of FIATs more complex ! public data structures are descendants of this type. ! use abstract_container_mod , only : container use iterator_mod , only : iterator implicit none private type , abstract , public :: iterable !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract type which can return and [[iterator]] object ! representing its contents. All of the more complex public data ! structures in FIAT are descendants of this one. ! contains procedure ( iterator_return ), deferred :: iter !! Return an [[iterator]] object with the contents of the iterable procedure ( container_return ), deferred :: contents_type !! Return a [[container]] object with the dynamic type of that !! used in this iterable end type iterable abstract interface pure function iterator_return ( this ) import :: iterable import :: iterator class ( iterable ), intent ( in ) :: this type ( iterator ) :: iterator_return !! An [[iterator]] with the contents of this object end function iterator_return pure function container_return ( this ) import :: iterable import :: container class ( iterable ), intent ( in ) :: this class ( container ), allocatable :: container_return !! A container of the dynamic type used in this object end function container_return end interface end module iterable_mod","tags":"","loc":"sourcefile/iterable.f90.html","title":"iterable.f90 – FIAT"},{"text":"Source Code ! !  iterator.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module iterator_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides the [[iterator]] data type which can be used to access a ! collection of data. ! use abstract_container_mod , only : container implicit none private type , public :: iterator !* Author: Chris MacMackin !  Date: March 2016 ! ! A data type which provides a collection of data to the user. Objects ! of this type are returned using the [[iterable:iter]] method of ! FIAT's other data types. The contents of the iterator are set to be ! the same as the iterable at the time when the `iter` method was ! called. If new items are later added to the iterable object, this ! will not be reflected in the iterator object. ! !##Example ! If `list_obj` is some sort of [[list]] which contains character ! strings, then the following would print all strings held in the ! list. !```fortran !iterator_obj = list_obj%iter() !do while(iterator_obj%has_next()) !    string = iterator_obj%next() !    write(*,*) string !end do !``` ! private class ( container ), allocatable , dimension (:) :: contents integer :: location = 1 logical :: filled = . false . contains procedure :: has_next procedure :: next procedure :: reset procedure :: contents_type end type iterator interface iterator module procedure constructor end interface contains pure function constructor ( contents ) result ( new ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Creates an iterator from an array of containers containing ! the data to be returned upon iteration. The data is returned ! starting with the first element of the array and ending with ! the last. ! class ( container ), dimension (:), intent ( in ) :: contents type ( iterator ) :: new allocate ( new % contents ( size ( contents )), source = contents ) new % filled = . true . end function constructor elemental function has_next ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns `.true.` if there are any remaining objects through which ! to iterate, and `.false.` otherwise. ! class ( iterator ), intent ( in ) :: this logical :: has_next !! Whether there are additional items to iterate through has_next = this % location <= size ( this % contents ) end function has_next function next ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the next item stored in the iterator. If there are no ! more items present then an empty [[container]] is returned. If ! there are no contents stored in this iterator then it returns ! an unallocated [[container]]. ! class ( iterator ), intent ( inout ) :: this class ( container ), allocatable :: next !! The next item held in the iterator, if present. Otherwise !! an unallocated container. if (. not . this % filled ) return if ( this % location > size ( this % contents )) then allocate ( next , mold = this % contents ( 1 )) return end if allocate ( next , source = this % contents ( this % location )) this % location = this % location + 1 end function next subroutine reset ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Resets the position of the iterator to the start, so it is as ! though the [[iterator(type):next(bound)]] routine has never been ! called. ! class ( iterator ), intent ( inout ) :: this this % location = 1 end subroutine reset pure function contents_type ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a container with the dynamic type of that used to hold ! the contents of this iterator ! class ( iterator ), intent ( in ) :: this class ( container ), pointer :: contents_type !! A container with the dynamic type of that used to hold the !! contents of the iterator. It is a pointer as pointer assignment !! is the easiest way to hold its \"value\" in an abstract variable. if (. not . this % filled ) return allocate ( contents_type , mold = this % contents ( 1 )) end function contents_type end module iterator_mod","tags":"","loc":"sourcefile/iterator.f90.html","title":"iterator.f90 – FIAT"},{"text":"Source Code ! !  linked_node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module linked_node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Implements a node which contains a pointer to another (the next) ! node, allowing a chain to be formed. This can be used to, for ! example, build linked lists. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. ! use node_mod , only : node implicit none private type , extends ( node ), public :: linked_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at another ! (the next) linked_node or descendent type. This type can be built ! up into a chain, allowing a linked list to be formed. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( linked_node ), pointer :: next => null () !! The next node in the chain. contains procedure :: has_next !! Checks whether this node points to another one procedure :: get_next !! Returns the next node in the chain if it exists. procedure :: set_next !! Sets the next node in the chain. procedure :: unset_next !! Sets this node not to point at any others, severing the chain. end type linked_node contains elemental logical function has_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points at another one, forming ! a chain. ! class ( linked_node ), intent ( in ) :: this has_next = associated ( this % next ) end function has_next function get_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the node which this ones points to, i.e. the ! next node in the chain. If this node does not point at another ! one, then a null pointer is returned. ! class ( linked_node ), intent ( in ) :: this class ( linked_node ), pointer :: get_next if ( this % has_next ()) then get_next => this % next else get_next => null () end if end function get_next subroutine set_next ( this , new_next , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the node which this one points to (i.e. sets the next node in ! the chain). If this node already points to another one, the ! pointer will, by default, be nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this class ( linked_node ), pointer , intent ( in ) :: new_next !! The node which will now be next in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. call this % unset_next ( deallocate_old ) this % next => new_next end subroutine set_next subroutine unset_next ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the next node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. if (. not . this % has_next ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % next % unset_next (. true .) deallocate ( this % next ) return end if end if nullify ( this % next ) end subroutine unset_next end module linked_node_mod","tags":"","loc":"sourcefile/linked_node.f90.html","title":"linked_node.f90 – FIAT"},{"text":"Source Code ! !  list.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module list_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract data type representing a list. This interface ! provides a derived type with many of the same abilities as lists in ! higher-level languages such as Python. ! use deque_mod , only : deque use abstract_container_mod , only : container , test_func , & addition_func , subtraction_func , & comparison_func , action_sub implicit none private type , abstract , extends ( deque ), public :: list !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type representing a list. This is a fully dynamic ! means of storing data of a single type and comes with many advanced ! type-bound procedures for manipulating said data. This derived type ! aims to provide many of the same features found in lists in ! higher-level languages such as Python ! contains procedure ( append_sub ), deferred :: append !! Add an item to the end of the list procedure ( get_func ), deferred :: get !! Get the item at the specified index procedure ( set_single_sub ), deferred , private :: set_single !! Set the specified element to the specified value procedure ( set_multiple_sub ), deferred , private :: set_multiple !! Set the specified elements to the specified values generic :: set => set_single , set_multiple !! Set the value of one or more elements in the list procedure ( get_index_func ), deferred :: get_index !! Get the index of the first occurrence of this item in the list procedure ( get_last_index_func ), deferred :: get_last_index !! Get the index of the last occurrence of this item in the list procedure ( get_indices_func ), deferred :: get_indices !! Get the indices of all occurrences of this item in the list procedure ( slice_func ), deferred :: slice !! Returns a list containing the items with indices in the !! specified range procedure ( foreach_sub ), deferred :: foreach !! Perform the provided procedure on each element of the list procedure ( insert_sub ), deferred :: insert !! Add the item to the specified position in the list, moving !! all succeeding elements forward by one position procedure ( remove_sub ), deferred :: remove !! Remove the first occurrence of the specified item from the list procedure ( remove_last_sub ), deferred :: remove_last !! Remove the last occurrence of the specified item from the list procedure ( remove_all_sub ), deferred :: remove_all !! Remove the all occurrences of the specified item from the list procedure ( delete_single_sub ), deferred , private :: delete_single !! Remove the item from the list at the specified index procedure ( delete_multiple_sub ), deferred , private :: delete_multiple !! Remove the items from the list at the specified indices procedure ( delete_slice_sub ), deferred , private :: delete_slice !! Remove the items from the list within the specified slice generic :: delete => delete_single , delete_multiple , delete_slice !! Remove one or more elements from the list procedure ( has_func ), deferred :: has !! Returns `.true.` if the specified item is present in the list. procedure ( sort_sub ), deferred :: sort !! Sorts the list in place using the provided comparison procedure procedure ( min_func ), deferred :: min !! Returns the smallest item in the list as determined using the !! provided comparison procedure procedure ( max_func ), deferred :: max !! Returns the largest item in the list as determined using the !! provided comparison procedure procedure ( nearest_func ), deferred :: nearest !! Returns the item in the list for which the provided subtraction !! procedure returns the smallest absolute value procedure ( sum_func ), deferred :: sum !! Returns an item representing the sum as determined by !! iteratively applying the provided addition procedure to all !! elements in the list procedure ( filter_func ), deferred :: filter !! Returns a list containing all elements from this list for which !! the provided test procedure returns `.true.` procedure ( to_array_func ), deferred :: to_array !! Returns an array of containers holding the contents of this !! list. end type list abstract interface subroutine append_sub ( this , item ) import :: list class ( list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! Item to be appended to list end subroutine append_sub pure function get_func ( this , element ) import :: list import :: container class ( list ), intent ( in ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element to return class ( container ), allocatable :: get_func !! The item with index `element` end function get_func subroutine set_single_sub ( this , element , item ) import :: list class ( list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element whose value is to be set. class ( * ), intent ( in ) :: item !! The value to store in the specified element end subroutine set_single_sub subroutine set_multiple_sub ( this , elements , items ) import :: list class ( list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: elements !! The indices (starting from 1) of the elements whose values !! are to be set. class ( * ), dimension (:), intent ( in ) :: items !! The values to be stored in the specified elements. Each item !! is placed in the element specified by the integer in the !! corresponding position in the array `elements`. end subroutine set_multiple_sub pure function get_index_func ( this , item ) import :: list class ( list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: get_index_func !! Position of the first occurrence of `item` in list end function get_index_func pure function get_last_index_func ( this , item ) import :: list class ( list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: get_last_index_func !! Position of the last occurrence of `item` in list end function get_last_index_func pure function get_indices_func ( this , item ) import :: list class ( list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer , dimension (:), allocatable :: get_indices_func !! Positions of the all occurrences of `item` in list end function get_indices_func function slice_func ( this , start_element , end_element ) import :: list class ( list ), intent ( in ) :: this integer , intent ( in ) :: start_element !! The index of the first element in the slice to be returned integer , intent ( in ) :: end_element !! The index of the last element in the slice to be returned class ( list ), allocatable :: slice_func !! A list containing the elements within the slice. end function slice_func subroutine foreach_sub ( this , action ) import :: list import :: action_sub class ( list ), intent ( inout ) :: this procedure ( action_sub ) :: action !! A procedure to act on each element of the list end subroutine foreach_sub subroutine insert_sub ( this , position , item ) import :: list class ( list ), intent ( inout ) :: this integer , intent ( in ) :: position !! The location at which the new element will be placed class ( * ), intent ( in ) :: item !! The value to be placed in the list end subroutine insert_sub subroutine remove_sub ( this , item ) import :: list class ( list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the first occurrence of which will be removed from !! the list end subroutine remove_sub subroutine remove_last_sub ( this , item ) import :: list class ( list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the last occurrence of which will be removed from !! the list end subroutine remove_last_sub subroutine remove_all_sub ( this , item ) import :: list class ( list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, all occurrences of which will be removed from the !! list end subroutine remove_all_sub subroutine delete_single_sub ( this , element ) import :: list class ( list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The position of the element to be deleted from the list end subroutine delete_single_sub subroutine delete_multiple_sub ( this , element ) import :: list class ( list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: element !! The positions of the elements to be deleted from the list end subroutine delete_multiple_sub subroutine delete_slice_sub ( this , start_element , end_element ) import :: list class ( list ), intent ( inout ) :: this integer , intent ( in ) :: start_element !! Index of the first element in the slice to be deleted integer , intent ( in ) :: end_element !! Index of the last element in the slice to be deleted end subroutine delete_slice_sub elemental function has_func ( this , item ) import :: list class ( list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! A value whose presence in the list is being checked for logical :: has_func !! `.true.` if `item` is present in list, `.false.` otherwise end function has_func subroutine sort_sub ( this , comparison ) import :: list import :: comparison_func class ( list ), intent ( inout ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another end subroutine sort_sub pure function min_func ( this , comparison ) import :: list import :: comparison_func import :: container class ( list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: min_func !! The smallest item in the list, as determined by the !! `comparison` function end function min_func pure function max_func ( this , comparison ) import :: list import :: comparison_func import :: container class ( list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: max_func !! The largest item in the list, as determined by the !! `comparison` function end function max_func pure function nearest_func ( this , item , subtraction ) import :: list import :: container import :: subtraction_func class ( list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! The value which those in the list are being compared to procedure ( subtraction_func ) :: subtraction !! A function determining the magnitude of the difference !! between two items class ( container ), allocatable :: nearest_func !! The value from the list which, when passed to `subtraction` !! with `item` as the other argument, returns the smallest value end function nearest_func pure function sum_func ( this , addition ) import :: list import :: container import :: addition_func class ( list ), intent ( in ) :: this procedure ( addition_func ) :: addition !! A procedure performing addition between two [[container]] !! objects and returning the result in another container class ( container ), allocatable :: sum_func !! A container holding the sum of all of the items held within !! this list end function sum_func pure function filter_func ( this , test ) import :: list import :: test_func class ( list ), intent ( in ) :: this procedure ( test_func ) :: test !! A test for which the values that pass will be returned in a !! new list class ( list ), allocatable :: filter_func !! Contains those items in this list for which `test` returns !! `.true.` end function filter_func pure function to_array_func ( this ) import :: list import :: container class ( list ), intent ( in ) :: this class ( container ), dimension (:), allocatable :: to_array_func !! An array of [[container]] objects holding the contents of !! this list end function to_array_func end interface end module list_mod","tags":"","loc":"sourcefile/list.f90.html","title":"list.f90 – FIAT"},{"text":"Source Code ! !  map.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module map_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a standard map data structures. These ! are data structures which consist of key-value pairs, with only one ! value per key. It is similar to the ! [dictionary](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) ! type in Python. ! use abstract_container_mod , only : container use dictionary_mod , only : dictionary implicit none private type , public , extends ( dictionary ), abstract :: map !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for the standard map data structures. These are ! data structures which consist of key-value pairs, with only one ! value per key. It has similar functionality to the ! [dictionary](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) ! type in Python. ! contains procedure ( get_func ), deferred :: get !! Returns the value associated with the specified key. procedure ( update_sub ), deferred :: update !! Adds any key-value pairs in the second map not already present. !! Updates the value for all keys in this dictionary also present !! in the second dictionary. end type map abstract interface pure function get_func ( this , key ) import :: map import :: container class ( map ), intent ( in ) :: this class ( * ), intent ( in ) :: key !! The key whose associated value is to be returned class ( container ), allocatable :: get_func !! The value associated with the specified key end function get_func pure subroutine update_sub ( this , other ) import :: map class ( map ), intent ( inout ) :: this class ( map ), intent ( in ) :: other !! A map whose key-value pairs will be added to this one, !! overwriting as necessary. end subroutine update_sub end interface end module map_mod","tags":"","loc":"sourcefile/map.f90.html","title":"map.f90 – FIAT"},{"text":"Source Code ! !  multimap.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module multimap_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a multiple map data structure. These ! are data structures which consist of key-value pairs, potentially ! holding multiple values per key. ! use dictionary_mod , only : dictionary use array_list_mod , only : array_list use map_mod , only : map implicit none private type , public , extends ( dictionary ), abstract :: multimap !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for the standard map data structures. These are ! data structures which consist of key-value pairs, potentially ! holding multiple values per key. ! contains procedure ( get_func ), deferred :: get !! Returns a list of values associated with the specified key. procedure ( get_count_func ), deferred :: get_count !! Returns the number of values associated with the specified key. procedure ( update_map_sub ), deferred , private :: update_map !! Adds any key-value pairs in the standard map to this one. If a !! key does not already exist in this dictionary then it is !! created and assigned the corresponding value. Otherwise, the !! value in the other dictionary is just added to the values !! associated with the key in this one. procedure ( update_multimap_sub ), deferred , private :: update_multimap !! Adds any key-value pairs in the second multipmap to this one. !! If a key does not already exist in this dictionary then it is !! created and assigned the corresponding values. Otherwise, the !! values in the other dictionary add just added to the values !! associated with the key in this one. generic :: update => update_map , update_multimap !! Update this multimap's contents with those of another !! (multi)map procedure ( remove_val_sub ), deferred :: remove_value !! Remove the specified value from the specified key end type multimap abstract interface pure function get_func ( this , key ) import :: multimap import :: array_list class ( multimap ), intent ( in ) :: this class ( * ), intent ( in ) :: key !! The key whose associated values are to be returned type ( array_list ) :: get_func !! The values associated with the specified key end function get_func pure function get_count_func ( this , key ) import :: multimap class ( multimap ), intent ( in ) :: this class ( * ), intent ( in ) :: key !! The key whose associated values are to be counted integer :: get_func !! The number of values associated with the specified key end function get_count_func pure subroutine update_multimap_sub ( this , other ) import :: multimap class ( multimap ), intent ( inout ) :: this class ( multimap ), intent ( in ) :: other !! A multimap whose key-value pairs will be added to this one, !! adding values to any keys which already exist in this one. end subroutine update_multimap_sub pure subroutine update_map_sub ( this , other ) import :: multimap import :: map class ( multimap ), intent ( inout ) :: this class ( map ), intent ( in ) :: other !! A map whose key-value pairs will be added to this one, !! appending the value to any keys which already exist in this !! one. end subroutine update_map_sub pure subroutine remove_val_sub ( this , key , val ) import :: multimap class ( multimap ), intent ( inout ) :: this class ( * ), intent ( in ) :: key !! A key from which to remove a value class ( * ), intent ( in ) :: val !! A value which will be removed from `key`, if `key` has such !! a value. end subroutine remove_val_sub end interface end module multimap_mod","tags":"","loc":"sourcefile/multimap.f90.html","title":"multimap.f90 – FIAT"},{"text":"Source Code ! !  multiset.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module multiset_mod !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a multi-set data structure. These ! behave like a normal set, except they keep count of the number of ! times which an item has been added. ! use dynamic_set_mod , only : dynamic_set implicit none private type , public , extends ( dynamic_set ), abstract :: multiset !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a multi-set data structure. These ! behave like a normal set, except they keep count of the number of ! times which an item has been added. When an item is removed, the ! count will be decremented by 1. The item will only become absent ! from the list ([[data_set:has]] returns `.false.`) when the count ! reaches zero. ! contains procedure ( get_func ), deferred :: get !! Returns the number of times this item is present in the set. end type multiset abstract interface pure function get_func ( this , item ) import :: multiset class ( multiset ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! The item whose presence in the set is being checked integer :: get_func !! The number of times this item appears in the set end function get_func end interface end module multiset_mod","tags":"","loc":"sourcefile/multiset.f90.html","title":"multiset.f90 – FIAT"},{"text":"Source Code ! !  node.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module node_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides a [[node]] data type, for holding some sort of contents. ! While a node itself is unlikely to be very useful, various type ! extensions are also made which are then used to build more complex ! data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! use abstract_container_mod , only : container implicit none private type , public :: node !* Author: Chris MacMackin !  Date: February 2016 ! ! An object which contains a container that can be set to have ! arbitrary contents. While of limited use on its own, various ! derived types exist which are extensions of this one exist and ! are used to build more complex data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! private class ( container ), allocatable :: contents !! Contains the value held in this node. contains procedure , non_overridable :: has_contents !! Evaluates whether contents have been assigned to node. procedure , non_overridable :: get_contents !! Returns the value stored in the node. procedure , non_overridable :: set_contents !! Sets the value to be stored in the node. procedure , non_overridable :: unset_contents !! Removes the record of any value stored in the node. end type node contains elemental logical function has_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not a values has been assigned to the node. ! class ( node ), intent ( in ) :: this has_contents = allocated ( this % contents ) end function has_contents pure function get_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! An accessor returning a [[container]] object storing the value ! placed in the node. If the contents have not been set then an ! unallocated container is returned. ! class ( node ), intent ( in ) :: this class ( container ), allocatable :: get_contents !! The stored in the node. if ( this % has_contents ()) allocate ( get_contents , source = this % contents ) end function get_contents subroutine set_contents ( this , contents ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Places a new value into storage within the node. This value must ! already be heald within an allocatable [[container]]. The actual ! argument will be deallocated after the subroutine call, as its ! allocation is moved to the contents of the node. ! class ( node ), intent ( inout ) :: this class ( container ), intent ( inout ), allocatable :: contents !* The new value to be stored in this node. The actual argument ! will be deallocated during the process of assigning it to the ! node. call this % unset_contents () call move_alloc ( contents , this % contents ) end subroutine set_contents subroutine unset_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Deallocates the value stored within the  node. ! class ( node ), intent ( inout ) :: this if ( this % has_contents ()) deallocate ( this % contents ) end subroutine unset_contents end module node_mod","tags":"","loc":"sourcefile/node.f90.html","title":"node.f90 – FIAT"},{"text":"Source Code ! !  ordered.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module ordered_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides the [[ordered]] abstract type. This is a data structure for ! which the order of the elements is known. One of the effects of this ! is that order in which items are retrieved is determined by the ! order in which they are added to the data structure. ! use iterator_mod , only : iterator use iterable_mod , only : iterable use countable_mod , only : countable use abstract_container_mod , only : container implicit none private type , extends ( countable ), abstract , public :: ordered !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract type which is an ancestor for any data structure in ! which items are stored in a particular order. This means that ! the order in which items are placed in the structure will ! determine the order in which they are retrieved. Examples of data ! structures descending from this one are a [[stack]], [[queue]], or ! [[list]]. ! contains procedure ( push_sub ), deferred :: push !! Place a new item in the data structure procedure ( pop_func ), deferred :: pop !! Remove and return the next item from the data structure procedure ( peek_func ), deferred :: peek !! Return, but do not remove, the next item in the data structure procedure ( blank_sub ), deferred :: clear !! Remove all contents from the data structure procedure ( logical_return ), nopass , deferred :: is_fifo !! Indicates whether this is a first in first out or last in last !! out data type. procedure , private :: array_extend !! Add ([[ordered:push]]) the elements of an array to this data !! structure procedure , private :: iterator_extend !! Add ([[ordered::push]]) the contents of an [[iterator]] to !! this data structure. generic :: extend => array_extend , iterator_extend !! Place multiple new items in the data structure procedure ( concat_func ), private , deferred :: concat !! Join this object with another [[ordered]] object, returning !! the result. The contents of the returned object are ordered !! such that applying [[ordered:pop]] until the structure is !! empty would provide items in the same order as calling !! [[ordered:pop]] until the first object is empty and then until !! the second object is empty. generic :: operator ( // ) => concat !! Overloads the concatenation operator to join this object with !! another [[ordered]] object, returning the result. The contents !! of the returned object are ordered such that applying !! [[ordered:pop]] until the structure is empty would provide !! items in the same order as calling [[ordered:pop]] until the !! first object is empty and then until the second object is !! empty. end type ordered abstract interface pure subroutine push_sub ( this , item ) import :: ordered class ( ordered ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! Contents to be added to this data structure end subroutine push_sub function pop_func ( this ) import :: ordered import :: container class ( ordered ), intent ( inout ) :: this class ( container ), allocatable :: pop_func !! The next item in the data structure, which has been removed end function pop_func pure function peek_func ( this ) import :: ordered import :: container class ( ordered ), intent ( in ) :: this class ( container ), allocatable :: peek_func !! The next item in the data structure end function peek_func pure subroutine blank_sub ( this ) import ordered class ( ordered ), intent ( inout ) :: this end subroutine blank_sub pure function logical_return () import :: ordered logical :: logical_return !! True if first in first out structure, false if last in !! first out end function logical_return pure function concat_func ( lhs , rhs ) import :: ordered class ( ordered ), intent ( in ) :: lhs !! This object class ( ordered ), intent ( in ) :: rhs !! The object being concatenated to this one class ( ordered ), allocatable :: concat_func !! The result of the concatenation end function concat_func end interface contains subroutine array_extend ( this , items ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Adds the elements of an array to this object. ! @Bug `gfortran` does not yet support dimension(*) for unlimited ! polymorphic variables, so I have had to switch to using ! `dimension(:)` when compiling with it. This means that only ! 1D arrays are accepted with `gfortran`. ! class ( ordered ), intent ( inout ) :: this #ifdef __GFORTRAN__ class ( * ), dimension (:), intent ( in ) :: items #else class ( * ), dimension ( * ), intent ( in ) :: items #endif !! The items to be added to this data structure integer :: i do i = 1 , size ( items ) call this % push ( items ( i )) end do end subroutine array_extend subroutine iterator_extend ( this , items ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Adds the contents of an [[iterable]] object to this data structure. ! class ( ordered ), intent ( inout ) :: this class ( iterable ), intent ( inout ) :: items !! The iterable whose contents are to be added to this data !! structure. type ( iterator ) :: iter_items iter_items = items % iter () do while ( iter_items % has_next ()) call this % push ( iter_items % next ()) end do end subroutine iterator_extend end module ordered_mod","tags":"","loc":"sourcefile/ordered.f90.html","title":"ordered.F90 – FIAT"},{"text":"Source Code ! !  queue.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! module queue_mod !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! Provides an abstract data type representing a queue (first in first ! out) data structure. ! use ordered_mod , only : ordered implicit none private type , public , extends ( ordered ), abstract :: queue !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract data type representing the queue structure. This is ! largely a placeholder type, in case some methods specific to queues ! are added at a later time. However, it does implement the ! [[ordered:is_fifo]] method. ! private contains procedure , nopass :: is_fifo => queue_is_fifo !! Returns true, as queues are a first in first out data type. end type queue contains pure logical function queue_is_fifo () !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns `.true.`, indicating that queues are a \"first in first ! out\" data structure. ! queue_is_fifo = . true . end function queue_is_fifo end module queue_mod","tags":"","loc":"sourcefile/queue.f90.html","title":"queue.f90 – FIAT"},{"text":"Source Code ! !  iterator.f90 !  This file is part of FIAT. ! !  Copyright 2016 Christopher MacMackin <cmacmackin@gmail.com> ! !  This program is free software; you can redistribute it and/or modify !  it under the terms of the GNU Lesser General Public License as !  published by the Free Software Foundation; either version 3 of the !  License, or (at your option) any later version. ! !  This program is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU Lesser General Public License for more details. ! !  You should have received a copy of the GNU Lesser General Public !  License along with this program; if not, write to the Free Software !  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, !  MA 02110-1301, USA. ! !~ module stack_mod !~   use iso_fortran_env, only: stderr => error_unit !~   use iterator_mod, only: iterator !~   use ordered_mod, only: ordered !~   use abstract_container_mod, only: container !~   use linked_node_mod, only: linked_node !~   implicit none !~   private !~   type, extends(ordered), public :: stack !~     private !~     class(container), allocatable :: container_obj !~     type(linked_node), pointer :: head => null() !~     type(linked_node), pointer :: iter_pos => null() !~     integer :: num_nodes = 0 !~   contains !~     procedure :: has_next => stack_has_next !~     procedure :: next => stack_next !~     procedure :: reset => stack_reset !~     procedure :: copy => stack_copy !~     procedure :: size => stack_size !~     procedure :: push => stack_push !~     procedure :: pop => stack_pop !~     procedure :: peek => stack_peek !~     procedure :: clear => stack_clear !~     procedure, private :: stack_assign !~     generic :: assignment(=) =>  stack_assign !~     procedure, private :: concat => stack_concat !~     procedure, private :: move_head => stack_move_head !~     final :: stack_final !~   end type stack !~   interface stack !~     module procedure :: constructor !~   end interface stack !~ contains !~   function constructor(container_obj) result(new) !~     class(container), intent(in) :: container_obj !~     type(stack) :: new !~     allocate(new%container_obj, mold=container_obj) !~     new%iter_pos => new%head !~   end function constructor !~   elemental logical function stack_has_next(this) !~     class(stack), intent(in) :: this !~     stack_has_next = associated(this%iter_pos) !~   end function stack_has_next !~   function stack_next(this) !~     class(stack), intent(inout) :: this !~     class(container), allocatable :: stack_next !~     if (.not. this%has_next()) then !~       write(stderr,*) \"ERROR: Bottom of stack reached.\" !~ #ifdef __GFORTRAN__ !~       call backtrace !~ #endif !~       stop !~     end if !~     allocate(stack_next, source=this%iter_pos%get_contents()) !~     if (this%iter_pos%has_next()) then !~       this%iter_pos => this%iter_pos%get_next() !~     else !~       this%iter_pos => null() !~     end if !~   end function stack_next !~   subroutine stack_reset(this) !~     class(stack), intent(inout) :: this !~     this%iter_pos => this%head !~   end subroutine stack_reset !~   function stack_copy(this) !~     class(stack), intent(in) :: this !~     class(iterator), allocatable :: stack_copy !~     class(stack), allocatable :: tmp !~     type(linked_node), pointer :: node1, node2 => null() !~     allocate(tmp, source=this) !~     allocate(node1, source=this%head) !~     tmp%head => node1 !~     allocate(node2, source=node1%get_next()) !~     do while (associated(node2)) !~       call node1%set_next(node2) !~       nullify(node1) !~       node1 => node2 !~       nullify(node2) !~       allocate(node2, source=node1%get_next()) !~     end do !~     call move_alloc(tmp, stack_copy) !~   end function stack_copy !~   subroutine stack_assign(lhs, rhs) !~     class(stack), intent(out) :: lhs !~     class(stack), intent(in) :: rhs !~     class(iterator), allocatable :: copy !~     lhs%num_nodes = rhs%num_nodes !~     lhs%container_obj = rhs%container_obj !~     if (lhs%num_nodes > 0) then !~       call move_alloc(rhs%copy(), copy) !~       select type(copy) !~         class is(stack) !~           lhs%head => copy%head !~           lhs%iter_pos => copy%iter_pos !~           if (associated(copy%head)) nullify(copy%head) !~           if (associated(copy%iter_pos)) nullify(copy%iter_pos) !~       end select !~     end if !~   end subroutine stack_assign !~   integer function stack_size(this) !~     class(stack), intent(in) :: this !~     stack_size = this%num_nodes !~   end function stack_size !~   subroutine stack_push(this, item) !~     class(stack), intent(inout) :: this !~     class(*), intent(in) :: item !~     type(linked_node), pointer :: newnode !~     class(container), allocatable :: newcont !~     allocate(newnode) !~     allocate(newcont, source=this%container_obj) !~     call newcont%set(item) !~     call newnode%set_contents(newcont) !~     call newnode%set_next(this%head) !~     this%head => newnode !~     this%num_nodes = this%num_nodes + 1 !~   end subroutine stack_push !~   function stack_pop(this) result(item) !~     class(stack), intent(inout) :: this !~     class(container), allocatable :: item !~     type(linked_node), pointer :: tmp !~     item = this%peek() !~     tmp => this%head !~     this%head => this%head%get_next() !~     deallocate(tmp) !~     this%num_nodes = this%num_nodes - 1 !~   end function stack_pop !~   subroutine stack_clear(this) !~     class(stack), intent(inout) :: this !~   contains !~     subroutine blank_stack(s) !~       class(stack), intent(out) :: s !~     end subroutine blank_stack !~   end subroutine stack_clear !~   function stack_peek(this) result(item) !~     class(stack), intent(in) :: this !~     class(container), allocatable :: item !~     item = this%head%get_contents() !~   end function stack_peek !~   function stack_concat(lhs, rhs) !~     class(stack), intent(in) :: lhs, rhs !~     class(ordered), allocatable :: stack_concat !~     type(stack), allocatable :: tmp_concat !~     type(stack) :: tmp_stack !~     type(linked_node), pointer :: tail !~     tmp_stack = lhs%copy() !~     tmp_concat%head => tmp%move_head() !~     if (tmp_concat%size() == 0) then !~       tmp_stack = rhs%copy() !~       tmp_concat%head => tmp_stack%move_head() !~     else !~       tail => tmp_concat%head !~       do while(tail%has_next()) !~         tail => tail%get_next() !~       end do !~       tmp_stack = rhs%copy() !~       call tail%set_next(tmp_stack%move_head()) !~     end if !~     nullify(tail) !~     call move_alloc(tmp_concat, stack_concat) !~   end function stack_concat !~   function stack_move_head(this) result(move_head) !~     class(stack), intent(inout) :: this !~     type(linked_node), pointer :: move_head !~     move_head => this%head !~     nullify(this%head) !~   end function stack_move_head !~   subroutine stack_final(this) !~     type(stack), intent(inout) :: this !~     nullify(this%iter_pos) !~     call this%head%unset_next(.true.) !~     deallocate(this%head) !~   end subroutine stack_final !~ end module stack_mod","tags":"","loc":"sourcefile/stack.f90.html","title":"stack.F90 – FIAT"},{"text":"type, public, abstract :: container An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows: module example_container_mod use abstract_container_mod implicit none private type example integer , public :: i end type example type , extends ( container ) :: example_container contains private procedure :: typeguard => example_guard end type example_container contains logical function example_guard ( this , lhs ) result ( ret ) class ( example_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( example ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function example_guard end module example_container_mod Inherited By type~~container~~InheritedByGraph type~container container type~array_list array_list type~container->type~array_list contents type~node node type~container->type~node contents type~iterator iterator type~container->type~iterator contents type~int4_container int4_container type~container->type~int4_container type~logical_container logical_container type~container->type~logical_container type~int2_container int2_container type~container->type~int2_container type~complex8_container complex8_container type~container->type~complex8_container type~int_container int_container type~container->type~int_container type~real_container real_container type~container->type~real_container type~complex16_container complex16_container type~container->type~complex16_container type~real4_container real4_container type~container->type~real4_container type~complex_container complex_container type~container->type~complex_container type~int1_container int1_container type~container->type~int1_container type~complex4_container complex4_container type~container->type~complex4_container type~int8_container int8_container type~container->type~int8_container type~character_container character_container type~container->type~character_container type~real16_container real16_container type~container->type~real16_container type~real8_container real8_container type~container->type~real8_container type~linked_node linked_node type~node->type~linked_node type~linked_node->type~linked_node next type~bidir_node bidir_node type~linked_node->type~bidir_node type~bidir_node->type~bidir_node prev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=i1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure( guard ), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. function guard (this, lhs) Prototype Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical procedure, public :: contents Retrieves the contents of the container, in the form of an\n integer array. private pure function contents (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Author Chris MacMackin Date December 2015 Returns the contents, encoded as a character array, of the \n container. procedure, public :: is_filled Returns whether contents have been assigned to the container private elemental function is_filled (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date March 2016 Returns .true. if a value has been assigned to the container, .false. otherwise. procedure, public :: set Sets the contents of the container. private subroutine set (this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Author Chris MacMackin Date December 2015 Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. procedure, private :: is_equal Check whether two containers have the same contents. private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. generic, public :: assignment(=) => assign_container private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. generic, public :: operator(==) => is_equal private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. Source Code type , public , abstract :: container !! Author: Chris MacMackin !! Date: December 2015 !! Display: Public !!          Private !! !! An abstract derived type which contains data. This type can be !! used for a sort of unlimited polymorphism. It is extended to !! create different classes capable of holding particular !! data-types. Extensions must implement the procedure !! [[container:typeguard]] in order to provide the ability to !! transfer data out of the container and into a variable. Assuming !! that you are creating a concrete class called !! `example_container`, this should be implemented as follows: !! !!```fortran !! module example_container_mod !! !!   use abstract_container_mod !!   implicit none !!   private !! !!   type example !!     integer, public :: i !!   end type example !! !!   type, extends(container) :: example_container !!   contains !!     private !!     procedure :: typeguard => example_guard !!   end type example_container !! !! contains !! !!   logical function example_guard(this, lhs) result(ret) !!     class(example_container), intent(in) :: this !!     class(*), intent(inout) :: lhs !!     select type(lhs) !!       type is(example) !!         lhs = transfer(this%contents(), lhs) !!         ret = .true. !!       class default !!         ret = .false. !!     end select !!   end function example_guard !! !! end module example_container_mod !!``` private integer ( i1 ), dimension (:), allocatable :: storage !! Variable in which to place data contents logical :: filled = . false . !! `.true.` if container is set, `.false.` otherwise contains private procedure ( guard ), deferred :: typeguard !! Performs the actual transfer of the container's contents to !! another variable. procedure , public :: contents !! Retrieves the contents of the container, in the form of an !! integer array. procedure , public :: is_filled !! Returns whether contents have been assigned to the container procedure , public :: set !! Sets the contents of the container. procedure , pass ( rhs ) :: assign_container !! Assigns container contents to another variable. procedure :: is_equal !! Check whether two containers have the same contents. generic , public :: assignment ( = ) => assign_container generic , public :: operator ( == ) => is_equal end type container","tags":"","loc":"type/container.html","title":"container – FIAT "},{"text":"type, public, extends( list ) :: array_list type~~array_list~~InheritsGraph type~array_list array_list type~container container type~container->type~array_list contents type~list list type~list->type~array_list type~deque deque type~deque->type~list type~queue queue type~queue->type~deque type~ordered ordered type~ordered->type~queue type~countable countable type~countable->type~ordered type~iterable iterable type~iterable->type~countable var pantypearray_listInheritsGraph = svgPanZoom('#typearray_listInheritsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A concrete implementation of the list abstract data type.\n This implementation stores list contents in an array. It is fast\n to read from, but it is slow to insert elements into the middle\n of the list or to add new items to the end (if doing so requires\n the storage array to be expanded). Note that this list is 1-indexed and that all slices are \n inclusive. In this regard, they are similar to arrays and strings\n in Fortran. Components Type Visibility Attributes Name Initial class( container ), private, allocatable, dimension(:) :: contents integer, private :: length Type-Bound Procedures procedure, public :: iter => array_list_iter private pure function array_list_iter (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Returns an iterator containing the contents of this list\n as they were at the time this method was called. procedure, public :: contents_type => array_list_contents_type private pure function array_list_contents_type (this) result(cont) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable Description Author Chris MacMackin Date March 2016 Returns a container with the dynamic type of the contents of this\n list. procedure, public :: size => array_list_size private pure function array_list_size (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value integer Description Author Chris MacMackin Date March 2016 Returns the number of items in the list procedure, public :: push => array_list_push private pure subroutine array_list_push (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item The value to place at the start of the list. Description Author Chris MacMackin Date March 2016 Adds an item to the beginning of the list. procedure, public :: pop => array_list_pop private function array_list_pop (this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The value from the end of the list Description Author Chris MacMackin Date March 2016 Removes the item at the end of the list and returns it. procedure, public :: peek => array_list_peek private pure function array_list_peek (this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The element at the end of the list Description Author Chris MacMackin Date March 2016 Returns the item at the end of the list, without removing it. procedure, private :: concat => array_list_concat private pure function array_list_concat (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: lhs The list class( ordered ), intent(in) :: rhs The object being concatenated to the list Return Value class( ordered ),\n  allocatable The concatenated object. Will have dynamic type array_list . Description Author Chris MacMackin Date March 2016 Join this list with an ordered object, returning the result. The \n contents of the returned object are ordered such that applying pop until it is empty would return items in the same order as \n calling pop until the list is empty and then until the second \n object is empty. procedure, public :: clear => array_list_clear private pure subroutine array_list_clear (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Description Author Chris MacMackin Date March 2016 Removes all items from this list, but does not change its container type. procedure, public :: pushleft => array_list_push private pure subroutine array_list_push (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item The value to place at the start of the list. Description Author Chris MacMackin Date March 2016 Adds an item to the beginning of the list. procedure, public :: pushright => array_list_append private pure subroutine array_list_append (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list Description Author Chris MacMackin Date March 2016 Adds the provided item to the end of the list. procedure, public :: popleft => array_list_popleft private function array_list_popleft (this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The item just removed from the start of the list Description Author Chris MacMackin Date March 2016 Removes the item at the start of the list and returns it. procedure, public :: popright => array_list_pop private function array_list_pop (this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The value from the end of the list Description Author Chris MacMackin Date March 2016 Removes the item at the end of the list and returns it. procedure, public :: peekleft => array_list_peekleft private pure function array_list_peekleft (this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The item at the start of the list Description Author Chris MacMackin Date March 2016 Returns the item at the start of the list. procedure, public :: peekright => array_list_peek private pure function array_list_peek (this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The element at the end of the list Description Author Chris MacMackin Date March 2016 Returns the item at the end of the list, without removing it. procedure, public :: append => array_list_append private pure subroutine array_list_append (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list Description Author Chris MacMackin Date March 2016 Adds the provided item to the end of the list. procedure, public :: get => array_list_get private pure function array_list_get (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element . Unallocated if no such element\n is present. Description Author Chris MacMackin Date March 2016 Returns the item at the specified location in the list. Returns\n an unallocated container if that location has not been set. procedure, private :: set_single => array_list_set_single private subroutine array_list_set_single (this, element, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element Description Author Chris MacMackin Date March 2016 Places the value of the provided element in the specified location\n in the array. Crashes if this element is not already defined. procedure, private :: set_multiple => array_list_set_multiple private subroutine array_list_set_multiple (this, elements, items) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . Description Author Chris MacMackin Date March 2016 Places the values of the provided array of items in the locations\n specified by the corresponding indices in the in the array of\n elements. procedure, public :: get_index => array_list_get_index private pure function array_list_get_index (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list Description Author Chris MacMackin Date March 2016 Returns the index of the first occurrence of the item in the list.\n If there are no occurrences, then returns -1. procedure, public :: get_last_index => array_list_get_last_index private pure function array_list_get_last_index (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list. -1 if item not present Description Author Chris MacMackin Date March 2016 Returns the index of the last occurrence of the item in the list.\n If there are no occurrences, then returns -1. procedure, public :: get_indices => array_list_get_indices private pure function array_list_get_indices (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list. Unallocated\n if item not present. Description Author Chris MacMackin Date March 2016 Returns an array containing the indices of all occurrences of the\n item in the list. If there are no occurrences, then returns an\n unallocated array. procedure, public :: slice => array_list_slice private function array_list_slice (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable An array_list containing the elements within the slice. Description Author Chris MacMackin Date March 2016 Returns an array_list instance containing all items in this\n list within the specified slice, inclusive. Crashes if one of\n the indices is outside of the list's bounds. procedure, public :: foreach => array_list_foreach private subroutine array_list_foreach (this, action) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list Description Author Chris MacMackin Date March 2016 Performs the specified action on each item in the list, in place. procedure, public :: insert => array_list_insert private subroutine array_list_insert (this, position, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list Description Author Chris MacMackin Date March 2016 Places the provided item into the list at the position specified,\n moving all succeeding items forward by one. The position must be\n one which is already filled or the length of the list plus one. procedure, public :: remove => array_list_remove private subroutine array_list_remove (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list Description Author Chris MacMackin Date March 2016 Remove the first occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. procedure, public :: remove_last => array_list_remove_last private subroutine array_list_remove_last (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list Description Author Chris MacMackin Date March 2016 Remove the last occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. procedure, public :: remove_all => array_list_remove_all private subroutine array_list_remove_all (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list Description Author Chris MacMackin Date March 2016 Remove all occurrences of the specified item from the list,\n moving all succeeding items back in position. No action is taken\n if the item is not present. procedure, private :: delete_single => array_list_delete_single private subroutine array_list_delete_single (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list Description Author Chris MacMackin Date March 2016 Removes the element at the specified position in the list, moving\n all succeeding items back by one position. Crashes if the element\n has not been set. procedure, private :: delete_multiple => array_list_delete_multiple private subroutine array_list_delete_multiple (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list Description Author Chris MacMackin Date March 2016 Removes the elements at the positions specified by the indices in\n the array elements from the list. The elements removed are those\n at the specified location just before the call was made. Once all\n removals have been performed, the remaining elements well be moved\n backwards in position as necessary. Crashes if an element has not\n been set. procedure, private :: delete_slice => array_list_delete_slice private subroutine array_list_delete_slice (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted Description Author Chris MacMackin Date March 2016 Removes the element within the specified slice of the list, moving\n all succeeding items back by the number of items deleted. The \n slice contains the element at the start index to the end index,\n inclusive. Crashes if part of the slice has not been set. procedure, public :: has => array_list_has private elemental function array_list_has (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise Description Author Chris MacMackin Date March 2016 Indicates whether there are any copies of the specified item\n present in the list. procedure, public :: sort => array_list_sort private subroutine array_list_sort (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Description Author Chris MacMackin Date March 2016 Sorts the list, in place, so that all items are in ascending order\n according the the provided comparison function. procedure, public :: min => array_list_min private pure function array_list_min (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function Description Author Chris MacMackin Date March 2016 Returns the smallest item contained in the list, as determined\n using the provided comparison function. procedure, public :: max => array_list_max private pure function array_list_max (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function Description Author Chris MacMackin Date March 2016 Returns the largest item contained in the list, as determined\n using the provided comparison function. procedure, public :: nearest => array_list_nearest private pure function array_list_nearest (this, item, subtraction) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value Description Author Chris MacMackin Date March 2016 Returns the value contained in the list for which the subtraction\n function returns the smallest absolute real number when comparing\n with the specified item . procedure, public :: sum => array_list_sum private pure function array_list_sum (this, addition) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list Description Author Chris MacMackin Date March 2016 Returns a container representing the sum of all items \n contained in the list. This sum is calculated by repeatedly\n applying the addition procedure to the list's contents. procedure, public :: filter => array_list_filter private pure function array_list_filter (this, test) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true. Description Author Chris MacMackin Date March 2016 Returns a new list containing only those items held in this list\n which pass the provided test. procedure, public :: to_array => array_list_to_array private pure function array_list_to_array (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list Description Author Chris MacMackin Date March 2016 Returns copies of all items held in this list, stored within an\n array of container objects. Source Code type , public , extends ( list ) :: array_list !* Author: Chris MacMackin !  Date: March 2016 ! ! A concrete implementation of the [[list]] abstract data type. ! This implementation stores list contents in an array. It is fast ! to read from, but it is slow to insert elements into the middle ! of the list or to add new items to the end (if doing so requires ! the storage array to be expanded). ! ! Note that this list is 1-indexed and that all slices are ! inclusive. In this regard, they are similar to arrays and strings ! in Fortran. ! private class ( container ), allocatable , dimension (:) :: contents integer :: length contains procedure :: iter => array_list_iter procedure :: contents_type => array_list_contents_type procedure :: size => array_list_size procedure :: push => array_list_push procedure :: pop => array_list_pop procedure :: peek => array_list_peek procedure , private :: concat => array_list_concat procedure :: clear => array_list_clear procedure :: pushleft => array_list_push procedure :: pushright => array_list_append procedure :: popleft => array_list_popleft procedure :: popright => array_list_pop procedure :: peekleft => array_list_peekleft procedure :: peekright => array_list_peek procedure :: append => array_list_append procedure :: get => array_list_get procedure , private :: set_single => array_list_set_single procedure , private :: set_multiple => array_list_set_multiple procedure :: get_index => array_list_get_index procedure :: get_last_index => array_list_get_last_index procedure :: get_indices => array_list_get_indices procedure :: slice => array_list_slice procedure :: foreach => array_list_foreach procedure :: insert => array_list_insert procedure :: remove => array_list_remove procedure :: remove_last => array_list_remove_last procedure :: remove_all => array_list_remove_all procedure , private :: delete_single => array_list_delete_single procedure , private :: delete_multiple => array_list_delete_multiple procedure , private :: delete_slice => array_list_delete_slice procedure :: has => array_list_has procedure :: sort => array_list_sort procedure :: min => array_list_min procedure :: max => array_list_max procedure :: nearest => array_list_nearest procedure :: sum => array_list_sum procedure :: filter => array_list_filter procedure :: to_array => array_list_to_array end type array_list","tags":"","loc":"type/array_list.html","title":"array_list – FIAT "},{"text":"type, public, extends( linked_node ) :: bidir_node type~~bidir_node~~InheritsGraph type~bidir_node bidir_node type~bidir_node->type~bidir_node prev type~linked_node linked_node type~linked_node->type~bidir_node type~linked_node->type~linked_node next type~node node type~node->type~linked_node type~container container type~container->type~node contents Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A node which, in addition to holding a value, points at two other\n (the previous and next) bidir_node objects or objects of a\n descendent type. This type can be built up into a chain, allowing\n a doubly-linked list to be formed. It is not anticipated that the bidir_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. As such, care must\n be taken when using certain methods (see below) to avoid memory\n leaks or segfaults. Components Type Visibility Attributes Name Initial class( bidir_node ), private, pointer :: prev => null() Type-Bound Procedures procedure, public :: has_prev private elemental function has_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. procedure, public :: get_prev private function get_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. procedure, public :: set_prev private subroutine set_prev (this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. procedure, public :: unset_prev private subroutine unset_prev (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node. Source Code type , extends ( linked_node ), public :: bidir_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at two other ! (the previous and next) bidir_node objects or objects of a ! descendent type. This type can be built up into a chain, allowing ! a doubly-linked list to be formed. ! ! It is not anticipated that the bidir_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( bidir_node ), pointer :: prev => null () contains procedure :: has_prev procedure :: get_prev procedure :: set_prev procedure :: unset_prev end type bidir_node","tags":"","loc":"type/bidir_node.html","title":"bidir_node – FIAT "},{"text":"type, public, extends( container ) :: int_container type~~int_container~~InheritsGraph type~int_container int_container type~container container type~container->type~int_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt integer type. Type-Bound Procedures procedure, private :: typeguard => int_guard private function int_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt integer type. contains private procedure :: typeguard => int_guard end type int_container","tags":"","loc":"type/int_container.html","title":"int_container – FIAT "},{"text":"type, public, extends( container ) :: int1_container type~~int1_container~~InheritsGraph type~int1_container int1_container type~container container type~container->type~int1_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 1 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int1_guard private function int1_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int1_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 1 byte integer type. contains private procedure :: typeguard => int1_guard end type int1_container","tags":"","loc":"type/int1_container.html","title":"int1_container – FIAT "},{"text":"type, public, extends( container ) :: int2_container type~~int2_container~~InheritsGraph type~int2_container int2_container type~container container type~container->type~int2_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 2 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int2_guard private function int2_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int2_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 2 byte integer type. contains private procedure :: typeguard => int2_guard end type int2_container","tags":"","loc":"type/int2_container.html","title":"int2_container – FIAT "},{"text":"type, public, extends( container ) :: int4_container type~~int4_container~~InheritsGraph type~int4_container int4_container type~container container type~container->type~int4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int4_guard private function int4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte integer type. contains private procedure :: typeguard => int4_guard end type int4_container","tags":"","loc":"type/int4_container.html","title":"int4_container – FIAT "},{"text":"type, public, extends( container ) :: int8_container type~~int8_container~~InheritsGraph type~int8_container int8_container type~container container type~container->type~int8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte integer type. Type-Bound Procedures procedure, private :: typeguard => int8_guard private function int8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: int8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte integer type. contains private procedure :: typeguard => int8_guard end type int8_container","tags":"","loc":"type/int8_container.html","title":"int8_container – FIAT "},{"text":"type, public, extends( container ) :: real_container type~~real_container~~InheritsGraph type~real_container real_container type~container container type~container->type~real_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt real type. Type-Bound Procedures procedure, private :: typeguard => real_guard private function real_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt real type. contains private procedure :: typeguard => real_guard end type real_container","tags":"","loc":"type/real_container.html","title":"real_container – FIAT "},{"text":"type, public, extends( container ) :: real4_container type~~real4_container~~InheritsGraph type~real4_container real4_container type~container container type~container->type~real4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte real type. Type-Bound Procedures procedure, private :: typeguard => real4_guard private function real4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte real type. contains private procedure :: typeguard => real4_guard end type real4_container","tags":"","loc":"type/real4_container.html","title":"real4_container – FIAT "},{"text":"type, public, extends( container ) :: real8_container type~~real8_container~~InheritsGraph type~real8_container real8_container type~container container type~container->type~real8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte real type. Type-Bound Procedures procedure, private :: typeguard => real8_guard private function real8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte real type. contains private procedure :: typeguard => real8_guard end type real8_container","tags":"","loc":"type/real8_container.html","title":"real8_container – FIAT "},{"text":"type, public, extends( container ) :: real16_container type~~real16_container~~InheritsGraph type~real16_container real16_container type~container container type~container->type~real16_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 16 byte real type. Type-Bound Procedures procedure, private :: typeguard => real16_guard private function real16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: real16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte real type. contains private procedure :: typeguard => real16_guard end type real16_container","tags":"","loc":"type/real16_container.html","title":"real16_container – FIAT "},{"text":"type, public, extends( container ) :: complex_container type~~complex_container~~InheritsGraph type~complex_container complex_container type~container container type~container->type~complex_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt complex type. Type-Bound Procedures procedure, private :: typeguard => complex_guard private function complex_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt complex type. contains private procedure :: typeguard => complex_guard end type complex_container","tags":"","loc":"type/complex_container.html","title":"complex_container – FIAT "},{"text":"type, public, extends( container ) :: complex4_container type~~complex4_container~~InheritsGraph type~complex4_container complex4_container type~container container type~container->type~complex4_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 4 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex4_guard private function complex4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex4_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 4 byte complex type. contains private procedure :: typeguard => complex4_guard end type complex4_container","tags":"","loc":"type/complex4_container.html","title":"complex4_container – FIAT "},{"text":"type, public, extends( container ) :: complex8_container type~~complex8_container~~InheritsGraph type~complex8_container complex8_container type~container container type~container->type~complex8_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 8 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex8_guard private function complex8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex8_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 8 byte complex type. contains private procedure :: typeguard => complex8_guard end type complex8_container","tags":"","loc":"type/complex8_container.html","title":"complex8_container – FIAT "},{"text":"type, public, extends( container ) :: complex16_container type~~complex16_container~~InheritsGraph type~complex16_container complex16_container type~container container type~container->type~complex16_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the 16 byte complex type. Type-Bound Procedures procedure, private :: typeguard => complex16_guard private function complex16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: complex16_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the 16 byte complex type. contains private procedure :: typeguard => complex16_guard end type complex16_container","tags":"","loc":"type/complex16_container.html","title":"complex16_container – FIAT "},{"text":"type, public, extends( container ) :: logical_container type~~logical_container~~InheritsGraph type~logical_container logical_container type~container container type~container->type~logical_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt logical type. Type-Bound Procedures procedure, private :: typeguard => logical_guard private function logical_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: logical_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt logical type. contains private procedure :: typeguard => logical_guard end type logical_container","tags":"","loc":"type/logical_container.html","title":"logical_container – FIAT "},{"text":"type, public, extends( container ) :: character_container type~~character_container~~InheritsGraph type~character_container character_container type~container container type~container->type~character_container Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A container for holding the defualt character type. Type-Bound Procedures procedure, private :: typeguard => character_guard private function character_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code type , extends ( container ) :: character_container !! Author: Chris MacMackin !! Date: December 2015 !! !! A container for holding the defualt character type. contains private procedure :: typeguard => character_guard end type character_container","tags":"","loc":"type/character_container.html","title":"character_container – FIAT "},{"text":"type, public, abstract, extends( iterable ) :: countable type~~countable~~InheritsGraph type~countable countable type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract data type which can be iterated, for which the number of\n pieces of items of data stored within is known. Inherited By type~~countable~~InheritedByGraph type~countable countable type~ordered ordered type~countable->type~ordered type~data_set data_set type~countable->type~data_set type~queue queue type~ordered->type~queue type~dictionary dictionary type~data_set->type~dictionary type~dynamic_set dynamic_set type~data_set->type~dynamic_set type~deque deque type~queue->type~deque type~list list type~deque->type~list type~array_list array_list type~list->type~array_list type~map map type~dictionary->type~map type~multimap multimap type~dictionary->type~multimap type~multiset multiset type~dynamic_set->type~multiset Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( size_func ), public, deferred :: size Return the number of items stored within this object pure function size_func (this) Prototype Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer The number of items stored in this object. Source Code type , extends ( iterable ), abstract , public :: countable !* Author: Chris MacMackin !  Date: February 2016 !  License: LGPLv3 ! ! An abstract data type which can be iterated, for which the number of ! pieces of items of data stored within is known. ! contains procedure ( size_func ), deferred :: size !! Return the number of items stored within this object end type countable","tags":"","loc":"type/countable.html","title":"countable – FIAT "},{"text":"type, public, abstract, extends( countable ) :: data_set type~~data_set~~InheritsGraph type~data_set data_set type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract type for set data structures. These sets support a \n similar selection of operations as do their mathematical\n counterparts. The collection of methods for this type waas inspired\n by those available for the frozenset type in Python. Inherited By type~~data_set~~InheritedByGraph type~data_set data_set type~dictionary dictionary type~data_set->type~dictionary type~dynamic_set dynamic_set type~data_set->type~dynamic_set type~map map type~dictionary->type~map type~multimap multimap type~dictionary->type~multimap type~multiset multiset type~dynamic_set->type~multiset Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( union_func ), public, deferred :: union Returns a set containing the items held in this set and the\n passed set. pure function union_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing all elements found in this one and the other generic, public :: operator(+) => union Returns the union of the two sets pure function union_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing all elements found in this one and the other procedure( intersect_func ), public, deferred :: intersection Returns a set containing only the items present in both this\n set and the argument pure function intersect_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value integer procedure( diff_func ), public, deferred :: difference Returns a set containing the item present in this set but not\n present in the argument pure function diff_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in this one and not the other generic, public :: operator(-) => difference Returns the difference between the two sets pure function diff_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in this one and not the other procedure( pure_diff_func ), public, deferred :: symmetric_difference Returns a set containing those items present either only in \n this set or only in the argument pure function pure_diff_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in one, but not both, of this\n set or the other set procedure( relation_func ), public, deferred :: is_disjoint True if none of the items in this set are present in the \n argument pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( relation_func ), public, deferred :: is_subset True if every element in this set is also in the argument pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( relation_func ), public, deferred :: is_proper_subset True if every element in this set is also in the argument and\n this set is not equal to the argument pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( relation_func ), public, deferred :: is_superset True if every element in the argument is also present in this\n set. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( relation_func ), public, deferred :: is_proper_superset True if every element in the argument is also present in this\n set and the argument is not equal to this set. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( relation_func ), public, deferred :: is_equal True if this set and the argument contain only the same items. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true generic, public :: operator(<=) => is_subset True if every element in this set is also in the argument pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true generic, public :: operator(<) => is_proper_subset True if every element in this set is also in the argument and\n this set is not equal to the argument pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true generic, public :: operator(>=) => is_superset True if every element in the argument is also present in this\n set. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true generic, public :: operator(>) => is_proper_superset True if every element in the argument is also present in this\n set and the argument is not equal to this set. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true generic, public :: operator(==) => is_equal True if this set and the argument contain only the same items. pure function relation_func (this, other) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true procedure( has_func ), public, deferred :: has True if the argument is present in the set pure function has_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item An item which may be contained in the set Return Value logical Whether item is present in this set procedure( empty_func ), public, deferred :: is_empty True if the set contains no items pure function empty_func (this) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value logical .true. if this set contains no items procedure( peek_func ), public, deferred :: peek Returns an item, at random, from the set pure function peek_func (this) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value class( container ),\n  allocatable An item contained within the set. Is unallocated if the set\n is empty. procedure( filter_func ), public, deferred :: filter Returns a set containing all elements from this set for which\n the provided test procedure returns .true. pure function filter_func (this, test) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( data_set ),\n  allocatable Contains those items in this set for which test returns .true. procedure( enum_func ), public, deferred :: enumerate Returns an [array_list] containing all of the items present\n in this set. pure function enum_func (this) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value type( array_list ) A list containing copies of all of the items in this set procedure( min_func ), public, deferred :: min Returns the smallest item in the set as determined using the\n provided comparison procedure pure function min_func (this, comparison) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the set, as determined by the comparison function procedure( max_func ), public, deferred :: max Returns the largest item in the set as determined using the\n provided comparison procedure pure function max_func (this, comparison) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the set, as determined by the comparison function procedure( nearest_func ), public, deferred :: nearest Returns the item in the set for which the provided subtraction\n procedure returns the smallest absolute value pure function nearest_func (this, item, subtraction) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item The value which those in the set are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the set which, when passed to subtraction with item as the other argument, returns the smallest value procedure( sum_func ), public, deferred :: sum Returns an item representing the sum as determined by\n iteratively applying the provided addition procedure to all\n items in the set pure function sum_func (this, addition) Prototype Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this set Source Code type , public , extends ( countable ), abstract :: data_set !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for set data structures. These sets support a ! similar selection of operations as do their mathematical ! counterparts. The collection of methods for this type waas inspired ! by those available for the ! [frozenset](https://docs.python.org/2/library/stdtypes.html#frozenset) ! type in Python. ! contains procedure ( union_func ), deferred :: union !! Returns a set containing the items held in this set and the !! passed set. generic :: operator ( + ) => union !! Returns the union of the two sets procedure ( intersect_func ), deferred :: intersection !! Returns a set containing only the items present in both this !! set and the argument procedure ( diff_func ), deferred :: difference !! Returns a set containing the item present in this set but not !! present in the argument generic :: operator ( - ) => difference !! Returns the difference between the two sets procedure ( pure_diff_func ), deferred :: symmetric_difference !! Returns a set containing those items present either only in !! this set or only in the argument procedure ( relation_func ), deferred :: is_disjoint !! True if none of the items in this set are present in the !! argument procedure ( relation_func ), deferred :: is_subset !! True if every element in this set is also in the argument procedure ( relation_func ), deferred :: is_proper_subset !! True if every element in this set is also in the argument and !! this set is not equal to the argument procedure ( relation_func ), deferred :: is_superset !! True if every element in the argument is also present in this !! set. procedure ( relation_func ), deferred :: is_proper_superset !! True if every element in the argument is also present in this !! set and the argument is not equal to this set. procedure ( relation_func ), deferred :: is_equal !! True if this set and the argument contain only the same items. generic :: operator ( <= ) => is_subset !! True if every element in this set is also in the argument generic :: operator ( < ) => is_proper_subset !! True if every element in this set is also in the argument and !! this set is not equal to the argument generic :: operator ( >= ) => is_superset !! True if every element in the argument is also present in this !! set. generic :: operator ( > ) => is_proper_superset !! True if every element in the argument is also present in this !! set and the argument is not equal to this set. generic :: operator ( == ) => is_equal !! True if this set and the argument contain only the same items. procedure ( has_func ), deferred :: has !! True if the argument is present in the set procedure ( empty_func ), deferred :: is_empty !! True if the set contains no items procedure ( peek_func ), deferred :: peek !! Returns an item, at random, from the set procedure ( filter_func ), deferred :: filter !! Returns a set containing all elements from this set for which !! the provided test procedure returns `.true.` procedure ( enum_func ), deferred :: enumerate !! Returns an [array_list] containing all of the items present !! in this set. procedure ( min_func ), deferred :: min !! Returns the smallest item in the set as determined using the !! provided comparison procedure procedure ( max_func ), deferred :: max !! Returns the largest item in the set as determined using the !! provided comparison procedure procedure ( nearest_func ), deferred :: nearest !! Returns the item in the set for which the provided subtraction !! procedure returns the smallest absolute value procedure ( sum_func ), deferred :: sum !! Returns an item representing the sum as determined by !! iteratively applying the provided addition procedure to all !! items in the set end type data_set","tags":"","loc":"type/data_set.html","title":"data_set – FIAT "},{"text":"type, public, abstract, extends( queue ) :: deque type~~deque~~InheritsGraph type~deque deque type~queue queue type~queue->type~deque type~ordered ordered type~ordered->type~queue type~countable countable type~countable->type~ordered type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract data type representing the double ended queue data\n structure. Rather than just pushing items to one end (the \"left \n end\") and popping them from the other (the \"right end\"), items can\n be pushed or popped to/from either the right or the left. Inherited By type~~deque~~InheritedByGraph type~deque deque type~list list type~deque->type~list type~array_list array_list type~list->type~array_list Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( push_sub ), public, deferred :: pushleft Add an item to the left end of the data structure (equivalent\n to push on a queue) pure subroutine push_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this class(*), intent(in) :: item The value to be added to the list procedure( push_sub ), public, deferred :: pushright Add an item to the right end of the data structure pure subroutine push_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this class(*), intent(in) :: item The value to be added to the list procedure( pop_func ), public, deferred :: popleft Remove and return the item from the left end of the data\n structure function pop_func (this) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this Return Value class( container ),\n  allocatable The next value, which has just been removed procedure( pop_func ), public, deferred :: popright Remove and return the item from the right end of the data\n structure (equivalent to pop on a queue) function pop_func (this) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this Return Value class( container ),\n  allocatable The next value, which has just been removed procedure( peek_func ), public, deferred :: peekleft Return, but do not remove, the item at the left end of the data\n structure pure function peek_func (this) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(in) :: this Return Value class( container ),\n  allocatable The next value, which is not removed procedure( peek_func ), public, deferred :: peekright Return, but do not remove, the item at the left end of the data\n structure (equivalent to peek on a queue) pure function peek_func (this) Prototype Arguments Type Intent Optional Attributes Name class( deque ), intent(in) :: this Return Value class( container ),\n  allocatable The next value, which is not removed Source Code type , abstract , extends ( queue ), public :: deque !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type representing the double ended queue data ! structure. Rather than just pushing items to one end (the \"left ! end\") and popping them from the other (the \"right end\"), items can ! be pushed or popped to/from either the right or the left. ! contains procedure ( push_sub ), deferred :: pushleft !! Add an item to the left end of the data structure (equivalent !! to [[ordered:push]] on a queue) procedure ( push_sub ), deferred :: pushright !! Add an item to the right end of the data structure procedure ( pop_func ), deferred :: popleft !! Remove and return the item from the left end of the data !! structure procedure ( pop_func ), deferred :: popright !! Remove and return the item from the right end of the data !! structure (equivalent to [[ordered:pop]] on a queue) procedure ( peek_func ), deferred :: peekleft !! Return, but do not remove, the item at the left end of the data !! structure procedure ( peek_func ), deferred :: peekright !! Return, but do not remove, the item at the left end of the data !! structure (equivalent to [[ordered:peek]] on a queue) end type deque","tags":"","loc":"type/deque.html","title":"deque – FIAT "},{"text":"type, public, abstract, extends( data_set ) :: dictionary type~~dictionary~~InheritsGraph type~dictionary dictionary type~data_set data_set type~data_set->type~dictionary type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract type for mapping data structures. These are data \n structures which consist of key-value pairs. Examples of such\n structures are dictionaries in Python or a hash variable in Perl. Inherited By type~~dictionary~~InheritedByGraph type~dictionary dictionary type~map map type~dictionary->type~map type~multimap multimap type~dictionary->type~multimap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( keys_func ), public, deferred :: keys Returns a list of the keys in this dictionary pure function keys_func (this) Prototype Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the keys in this dictionary procedure( values_func ), public, deferred :: values Returns a list of the values stored in this dictionary, in the\n same order as the corresponding keys are returned when keys is called pure function values_func (this) Prototype Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the values in this dictionary,\n stored in the same order as their corresponding key would\n be were keys called procedure( set_func ), public, deferred :: set Sets the given key to the give value function set_func (this, key, val) Prototype Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: this class(*), intent(in) :: key The key whose value is to be set class(*), intent(in) :: val The value to be assigned to the specified key Return Value real procedure( type_func ), public, deferred :: key_type Returns a container of the dynamics type used to store keys pure function type_func (this) Prototype Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used to store this \n dictionary's keys or values. procedure( type_func ), public, deferred :: value_type Returns a container of dynamics the type used to store \n values pure function type_func (this) Prototype Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used to store this \n dictionary's keys or values. Source Code type , public , extends ( data_set ), abstract :: dictionary !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for mapping data structures. These are data ! structures which consist of key-value pairs. Examples of such ! structures are ! [dictionaries](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) ! in Python or a ! [hash](https://en.wikibooks.org/wiki/Perl_Programming/Hash_Variables) ! variable in Perl. ! contains procedure ( keys_func ), deferred :: keys !! Returns a list of the keys in this dictionary procedure ( values_func ), deferred :: values !! Returns a list of the values stored in this dictionary, in the !! same order as the corresponding keys are returned when !! [[dictionary:keys]] is called procedure ( set_func ), deferred :: set !! Sets the given key to the give value procedure ( type_func ), deferred :: key_type !! Returns a [[container]] of the dynamics type used to store keys procedure ( type_func ), deferred :: value_type !! Returns a [[container]] of dynamics the type used to store !! values end type dictionary","tags":"","loc":"type/dictionary.html","title":"dictionary – FIAT "},{"text":"type, public, abstract, extends( data_set ) :: dynamic_set type~~dynamic_set~~InheritsGraph type~dynamic_set dynamic_set type~data_set data_set type~data_set->type~dynamic_set type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract data type for dynamic sets. These are much like\n mathematical sets, but differ from the parent data_set type\n in that items can be added to or removed from the set. To\n accomplish this, various additional methods are available. This\n data type is similar to the set type in\n Python. Inherited By type~~dynamic_set~~InheritedByGraph type~dynamic_set dynamic_set type~multiset multiset type~dynamic_set->type~multiset Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( single_sub ), private, deferred :: add_single Places the item in the set, if not already present pure subroutine single_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set procedure( multiple_sub ), private, deferred :: add_multiple Places each item in the array into the set, if not already \n present pure subroutine multiple_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set generic, public :: add => add_single , add_multiple pure subroutine single_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set pure subroutine multiple_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set procedure( iter_sub ), public, deferred :: add_iter Places each item in the iterable into the set, if not already\n present. pure subroutine iter_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class( iterable ), intent(in) :: items An iterable containing items to add or remove from the set procedure( single_sub ), private, deferred :: remove_single Removes the item from the set, if present pure subroutine single_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set procedure( multiple_sub ), private, deferred :: remove_multiple Removes each item in the array from the set, if present pure subroutine multiple_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set generic, public :: remove => remove_single , remove_multiple pure subroutine single_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set pure subroutine multiple_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set procedure( iter_sub ), public, deferred :: remove_iter Removes each item in the iterable from the set, if present pure subroutine iter_sub (this, items) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class( iterable ), intent(in) :: items An iterable containing items to add or remove from the set procedure( pop_func ), public, deferred :: pop Removes a random item from the set and returns it function pop_func (this) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this Return Value class( container ),\n  allocatable A random item which has been removed from the set procedure( clear_sub ), public, deferred :: clear Removes all items from the set pure subroutine clear_sub (this) Prototype Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this Source Code type , public , abstract , extends ( data_set ) :: dynamic_set !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type for dynamic sets. These are much like ! mathematical sets, but differ from the parent [[data_set]] type ! in that items can be added to or removed from the set. To ! accomplish this, various additional methods are available. This ! data type is similar to the ! [set](https://docs.python.org/2/library/stdtypes.html#set) type in ! Python. ! contains procedure ( single_sub ), deferred , private :: add_single !! Places the item in the set, if not already present procedure ( multiple_sub ), deferred , private :: add_multiple !! Places each item in the array into the set, if not already !! present generic :: add => add_single , add_multiple procedure ( iter_sub ), deferred :: add_iter !! Places each item in the iterable into the set, if not already !! present. procedure ( single_sub ), deferred , private :: remove_single !! Removes the item from the set, if present procedure ( multiple_sub ), deferred , private :: remove_multiple !! Removes each item in the array from the set, if present generic :: remove => remove_single , remove_multiple procedure ( iter_sub ), deferred :: remove_iter !! Removes each item in the iterable from the set, if present procedure ( pop_func ), deferred :: pop !! Removes a random item from the set and returns it procedure ( clear_sub ), deferred :: clear !! Removes all items from the set end type dynamic_set","tags":"","loc":"type/dynamic_set.html","title":"dynamic_set – FIAT "},{"text":"type, public, abstract :: iterable An abstract type which can return and iterator object\n representing its contents. All of the more complex public data \n structures in FIAT are descendants of this one. Inherited By type~~iterable~~InheritedByGraph type~iterable iterable type~countable countable type~iterable->type~countable type~ordered ordered type~countable->type~ordered type~data_set data_set type~countable->type~data_set type~queue queue type~ordered->type~queue type~dictionary dictionary type~data_set->type~dictionary type~dynamic_set dynamic_set type~data_set->type~dynamic_set type~deque deque type~queue->type~deque type~list list type~deque->type~list type~array_list array_list type~list->type~array_list type~map map type~dictionary->type~map type~multimap multimap type~dictionary->type~multimap type~multiset multiset type~dynamic_set->type~multiset Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( iterator_return ), public, deferred :: iter Return an iterator object with the contents of the iterable pure function iterator_return (this) Prototype Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value type( iterator ) An iterator with the contents of this object procedure( container_return ), public, deferred :: contents_type Return a container object with the dynamic type of that\n used in this iterable pure function container_return (this) Prototype Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used in this object Source Code type , abstract , public :: iterable !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract type which can return and [[iterator]] object ! representing its contents. All of the more complex public data ! structures in FIAT are descendants of this one. ! contains procedure ( iterator_return ), deferred :: iter !! Return an [[iterator]] object with the contents of the iterable procedure ( container_return ), deferred :: contents_type !! Return a [[container]] object with the dynamic type of that !! used in this iterable end type iterable","tags":"","loc":"type/iterable.html","title":"iterable – FIAT "},{"text":"type, public :: iterator type~~iterator~~InheritsGraph type~iterator iterator type~container container type~container->type~iterator contents Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A data type which provides a collection of data to the user. Objects\n of this type are returned using the iter method of\n FIAT's other data types. The contents of the iterator are set to be\n the same as the iterable at the time when the iter method was \n called. If new items are later added to the iterable object, this\n will not be reflected in the iterator object. Example If list_obj is some sort of list which contains character\n strings, then the following would print all strings held in the\n list. iterator_obj = list_obj % iter () do while ( iterator_obj % has_next ()) string = iterator_obj % next () write ( * , * ) string end do Components Type Visibility Attributes Name Initial class( container ), private, allocatable, dimension(:) :: contents integer, private :: location = 1 logical, private :: filled = .false. Constructor public interface iterator private pure function constructor (contents) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in), dimension(:) :: contents Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last. Type-Bound Procedures procedure, public :: has_next private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical Whether there are additional items to iterate through Description Author Chris MacMackin Date March 2016 Returns .true. if there are any remaining objects through which\n to iterate, and .false. otherwise. procedure, public :: next private function next (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item held in the iterator, if present. Otherwise\n an unallocated container. Description Author Chris MacMackin Date March 2016 Returns the next item stored in the iterator. If there are no\n more items present then an empty container is returned. If\n there are no contents stored in this iterator then it returns\n an unallocated container . procedure, public :: reset private subroutine reset (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Description Author Chris MacMackin Date March 2016 Resets the position of the iterator to the start, so it is as\n though the next routine has never been\n called. procedure, public :: contents_type private pure function contents_type (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( container ),\n  pointer A container with the dynamic type of that used to hold the\n contents of the iterator. It is a pointer as pointer assignment\n is the easiest way to hold its \"value\" in an abstract variable. Description Author Chris MacMackin Date March 2016 Returns a container with the dynamic type of that used to hold\n the contents of this iterator Source Code type , public :: iterator !* Author: Chris MacMackin !  Date: March 2016 ! ! A data type which provides a collection of data to the user. Objects ! of this type are returned using the [[iterable:iter]] method of ! FIAT's other data types. The contents of the iterator are set to be ! the same as the iterable at the time when the `iter` method was ! called. If new items are later added to the iterable object, this ! will not be reflected in the iterator object. ! !##Example ! If `list_obj` is some sort of [[list]] which contains character ! strings, then the following would print all strings held in the ! list. !```fortran !iterator_obj = list_obj%iter() !do while(iterator_obj%has_next()) !    string = iterator_obj%next() !    write(*,*) string !end do !``` ! private class ( container ), allocatable , dimension (:) :: contents integer :: location = 1 logical :: filled = . false . contains procedure :: has_next procedure :: next procedure :: reset procedure :: contents_type end type iterator","tags":"","loc":"type/iterator.html","title":"iterator – FIAT "},{"text":"type, public, extends( node ) :: linked_node type~~linked_node~~InheritsGraph type~linked_node linked_node type~linked_node->type~linked_node next type~node node type~node->type~linked_node type~container container type~container->type~node contents Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. A node which, in addition to holding a value, points at another\n (the next) linked_node or descendent type. This type can be built\n up into a chain, allowing a linked list to be formed. It is not anticipated that the linked_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. As such, care must\n be taken when using certain methods (see below) to avoid memory\n leaks or segfaults. Inherited By type~~linked_node~~InheritedByGraph type~linked_node linked_node type~linked_node->type~linked_node next type~bidir_node bidir_node type~linked_node->type~bidir_node type~bidir_node->type~bidir_node prev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial class( linked_node ), private, pointer :: next => null() The next node in the chain. Type-Bound Procedures procedure, public :: has_next Checks whether this node points to another one private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points at another one, forming\n a chain. procedure, public :: get_next Returns the next node in the chain if it exists. private function get_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. procedure, public :: set_next Sets the next node in the chain. private subroutine set_next (this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. procedure, public :: unset_next Sets this node not to point at any others, severing the chain. private subroutine unset_next (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code type , extends ( node ), public :: linked_node !* Author: Chris MacMackin !  Date: February 2016 ! ! A node which, in addition to holding a value, points at another ! (the next) linked_node or descendent type. This type can be built ! up into a chain, allowing a linked list to be formed. ! ! It is not anticipated that the linked_node type, or any types ! extending it, will be handled directly by end users of FIAT; they ! are meant for internal use within this package. As such, care must ! be taken when using certain methods (see below) to avoid memory ! leaks or segfaults. ! private class ( linked_node ), pointer :: next => null () !! The next node in the chain. contains procedure :: has_next !! Checks whether this node points to another one procedure :: get_next !! Returns the next node in the chain if it exists. procedure :: set_next !! Sets the next node in the chain. procedure :: unset_next !! Sets this node not to point at any others, severing the chain. end type linked_node","tags":"","loc":"type/linked_node.html","title":"linked_node – FIAT "},{"text":"type, public, abstract, extends( deque ) :: list type~~list~~InheritsGraph type~list list type~deque deque type~deque->type~list type~queue queue type~queue->type~deque type~ordered ordered type~ordered->type~queue type~countable countable type~countable->type~ordered type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract data type representing a list. This is a fully dynamic\n means of storing data of a single type and comes with many advanced\n type-bound procedures for manipulating said data. This derived type\n aims to provide many of the same features found in lists in \n higher-level languages such as Python Inherited By type~~list~~InheritedByGraph type~list list type~array_list array_list type~list->type~array_list Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( append_sub ), public, deferred :: append Add an item to the end of the list subroutine append_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list procedure( get_func ), public, deferred :: get Get the item at the specified index pure function get_func (this, element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element procedure( set_single_sub ), private, deferred :: set_single Set the specified element to the specified value subroutine set_single_sub (this, element, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element procedure( set_multiple_sub ), private, deferred :: set_multiple Set the specified elements to the specified values subroutine set_multiple_sub (this, elements, items) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . generic, public :: set => set_single , set_multiple Set the value of one or more elements in the list subroutine set_single_sub (this, element, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element subroutine set_multiple_sub (this, elements, items) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . procedure( get_index_func ), public, deferred :: get_index Get the index of the first occurrence of this item in the list pure function get_index_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list procedure( get_last_index_func ), public, deferred :: get_last_index Get the index of the last occurrence of this item in the list pure function get_last_index_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list procedure( get_indices_func ), public, deferred :: get_indices Get the indices of all occurrences of this item in the list pure function get_indices_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list procedure( slice_func ), public, deferred :: slice Returns a list containing the items with indices in the\n specified range function slice_func (this, start_element, end_element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable A list containing the elements within the slice. procedure( foreach_sub ), public, deferred :: foreach Perform the provided procedure on each element of the list subroutine foreach_sub (this, action) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list procedure( insert_sub ), public, deferred :: insert Add the item to the specified position in the list, moving\n all succeeding elements forward by one position subroutine insert_sub (this, position, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list procedure( remove_sub ), public, deferred :: remove Remove the first occurrence of the specified item from the list subroutine remove_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list procedure( remove_last_sub ), public, deferred :: remove_last Remove the last occurrence of the specified item from the list subroutine remove_last_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list procedure( remove_all_sub ), public, deferred :: remove_all Remove the all occurrences of the specified item from the list subroutine remove_all_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list procedure( delete_single_sub ), private, deferred :: delete_single Remove the item from the list at the specified index subroutine delete_single_sub (this, element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list procedure( delete_multiple_sub ), private, deferred :: delete_multiple Remove the items from the list at the specified indices subroutine delete_multiple_sub (this, element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list procedure( delete_slice_sub ), private, deferred :: delete_slice Remove the items from the list within the specified slice subroutine delete_slice_sub (this, start_element, end_element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted generic, public :: delete => delete_single , delete_multiple , delete_slice Remove one or more elements from the list subroutine delete_single_sub (this, element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list subroutine delete_multiple_sub (this, element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list subroutine delete_slice_sub (this, start_element, end_element) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted procedure( has_func ), public, deferred :: has Returns .true. if the specified item is present in the list. elemental function has_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise procedure( sort_sub ), public, deferred :: sort Sorts the list in place using the provided comparison procedure subroutine sort_sub (this, comparison) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another procedure( min_func ), public, deferred :: min Returns the smallest item in the list as determined using the\n provided comparison procedure pure function min_func (this, comparison) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function procedure( max_func ), public, deferred :: max Returns the largest item in the list as determined using the\n provided comparison procedure pure function max_func (this, comparison) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function procedure( nearest_func ), public, deferred :: nearest Returns the item in the list for which the provided subtraction\n procedure returns the smallest absolute value pure function nearest_func (this, item, subtraction) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value procedure( sum_func ), public, deferred :: sum Returns an item representing the sum as determined by\n iteratively applying the provided addition procedure to all\n elements in the list pure function sum_func (this, addition) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list procedure( filter_func ), public, deferred :: filter Returns a list containing all elements from this list for which\n the provided test procedure returns .true. pure function filter_func (this, test) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true. procedure( to_array_func ), public, deferred :: to_array Returns an array of containers holding the contents of this\n list. pure function to_array_func (this) Prototype Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list Source Code type , abstract , extends ( deque ), public :: list !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract data type representing a list. This is a fully dynamic ! means of storing data of a single type and comes with many advanced ! type-bound procedures for manipulating said data. This derived type ! aims to provide many of the same features found in lists in ! higher-level languages such as Python ! contains procedure ( append_sub ), deferred :: append !! Add an item to the end of the list procedure ( get_func ), deferred :: get !! Get the item at the specified index procedure ( set_single_sub ), deferred , private :: set_single !! Set the specified element to the specified value procedure ( set_multiple_sub ), deferred , private :: set_multiple !! Set the specified elements to the specified values generic :: set => set_single , set_multiple !! Set the value of one or more elements in the list procedure ( get_index_func ), deferred :: get_index !! Get the index of the first occurrence of this item in the list procedure ( get_last_index_func ), deferred :: get_last_index !! Get the index of the last occurrence of this item in the list procedure ( get_indices_func ), deferred :: get_indices !! Get the indices of all occurrences of this item in the list procedure ( slice_func ), deferred :: slice !! Returns a list containing the items with indices in the !! specified range procedure ( foreach_sub ), deferred :: foreach !! Perform the provided procedure on each element of the list procedure ( insert_sub ), deferred :: insert !! Add the item to the specified position in the list, moving !! all succeeding elements forward by one position procedure ( remove_sub ), deferred :: remove !! Remove the first occurrence of the specified item from the list procedure ( remove_last_sub ), deferred :: remove_last !! Remove the last occurrence of the specified item from the list procedure ( remove_all_sub ), deferred :: remove_all !! Remove the all occurrences of the specified item from the list procedure ( delete_single_sub ), deferred , private :: delete_single !! Remove the item from the list at the specified index procedure ( delete_multiple_sub ), deferred , private :: delete_multiple !! Remove the items from the list at the specified indices procedure ( delete_slice_sub ), deferred , private :: delete_slice !! Remove the items from the list within the specified slice generic :: delete => delete_single , delete_multiple , delete_slice !! Remove one or more elements from the list procedure ( has_func ), deferred :: has !! Returns `.true.` if the specified item is present in the list. procedure ( sort_sub ), deferred :: sort !! Sorts the list in place using the provided comparison procedure procedure ( min_func ), deferred :: min !! Returns the smallest item in the list as determined using the !! provided comparison procedure procedure ( max_func ), deferred :: max !! Returns the largest item in the list as determined using the !! provided comparison procedure procedure ( nearest_func ), deferred :: nearest !! Returns the item in the list for which the provided subtraction !! procedure returns the smallest absolute value procedure ( sum_func ), deferred :: sum !! Returns an item representing the sum as determined by !! iteratively applying the provided addition procedure to all !! elements in the list procedure ( filter_func ), deferred :: filter !! Returns a list containing all elements from this list for which !! the provided test procedure returns `.true.` procedure ( to_array_func ), deferred :: to_array !! Returns an array of containers holding the contents of this !! list. end type list","tags":"","loc":"type/list.html","title":"list – FIAT "},{"text":"type, public, abstract, extends( dictionary ) :: map type~~map~~InheritsGraph type~map map type~dictionary dictionary type~dictionary->type~map type~data_set data_set type~data_set->type~dictionary type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract type for the standard map data structures. These are \n data structures which consist of key-value pairs, with only one \n value per key. It has similar functionality to the dictionary type in Python. Type-Bound Procedures procedure( get_func ), public, deferred :: get Returns the value associated with the specified key. pure function get_func (this, key) Prototype Arguments Type Intent Optional Attributes Name class( map ), intent(in) :: this class(*), intent(in) :: key The key whose associated value is to be returned Return Value class( container ),\n  allocatable The value associated with the specified key procedure( update_sub ), public, deferred :: update Adds any key-value pairs in the second map not already present.\n Updates the value for all keys in this dictionary also present \n in the second dictionary. pure subroutine update_sub (this, other) Prototype Arguments Type Intent Optional Attributes Name class( map ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n overwriting as necessary. Source Code type , public , extends ( dictionary ), abstract :: map !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for the standard map data structures. These are ! data structures which consist of key-value pairs, with only one ! value per key. It has similar functionality to the ! [dictionary](https://docs.python.org/2/library/stdtypes.html#mapping-types-dict) ! type in Python. ! contains procedure ( get_func ), deferred :: get !! Returns the value associated with the specified key. procedure ( update_sub ), deferred :: update !! Adds any key-value pairs in the second map not already present. !! Updates the value for all keys in this dictionary also present !! in the second dictionary. end type map","tags":"","loc":"type/map.html","title":"map – FIAT "},{"text":"type, public, abstract, extends( dictionary ) :: multimap type~~multimap~~InheritsGraph type~multimap multimap type~dictionary dictionary type~dictionary->type~multimap type~data_set data_set type~data_set->type~dictionary type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract type for the standard map data structures. These are \n data structures which consist of key-value pairs, potentially \n holding multiple values per key. Type-Bound Procedures procedure( get_func ), public, deferred :: get Returns a list of values associated with the specified key. pure function get_func (this, key) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be returned Return Value type( array_list ) The values associated with the specified key procedure( get_count_func ), public, deferred :: get_count Returns the number of values associated with the specified key. pure function get_count_func (this, key) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be counted Return Value real procedure( update_map_sub ), private, deferred :: update_map Adds any key-value pairs in the standard map to this one. If a\n key does not already exist in this dictionary then it is \n created and assigned the corresponding value. Otherwise, the\n value in the other dictionary is just added to the values \n associated with the key in this one. pure subroutine update_map_sub (this, other) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n appending the value to any keys which already exist in this\n one. procedure( update_multimap_sub ), private, deferred :: update_multimap Adds any key-value pairs in the second multipmap to this one.\n If a key does not already exist in this dictionary then it is\n created and assigned the corresponding values. Otherwise, the\n values in the other dictionary add just added to the values \n associated with the key in this one. pure subroutine update_multimap_sub (this, other) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( multimap ), intent(in) :: other A multimap whose key-value pairs will be added to this one,\n adding values to any keys which already exist in this one. generic, public :: update => update_map , update_multimap Update this multimap's contents with those of another \n (multi)map pure subroutine update_map_sub (this, other) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n appending the value to any keys which already exist in this\n one. pure subroutine update_multimap_sub (this, other) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( multimap ), intent(in) :: other A multimap whose key-value pairs will be added to this one,\n adding values to any keys which already exist in this one. procedure( remove_val_sub ), public, deferred :: remove_value Remove the specified value from the specified key pure subroutine remove_val_sub (this, key, val) Prototype Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class(*), intent(in) :: key A key from which to remove a value class(*), intent(in) :: val A value which will be removed from key , if key has such\n a value. Source Code type , public , extends ( dictionary ), abstract :: multimap !* Author: Chris MacMackin !  Date: March 2016 ! ! An abstract type for the standard map data structures. These are ! data structures which consist of key-value pairs, potentially ! holding multiple values per key. ! contains procedure ( get_func ), deferred :: get !! Returns a list of values associated with the specified key. procedure ( get_count_func ), deferred :: get_count !! Returns the number of values associated with the specified key. procedure ( update_map_sub ), deferred , private :: update_map !! Adds any key-value pairs in the standard map to this one. If a !! key does not already exist in this dictionary then it is !! created and assigned the corresponding value. Otherwise, the !! value in the other dictionary is just added to the values !! associated with the key in this one. procedure ( update_multimap_sub ), deferred , private :: update_multimap !! Adds any key-value pairs in the second multipmap to this one. !! If a key does not already exist in this dictionary then it is !! created and assigned the corresponding values. Otherwise, the !! values in the other dictionary add just added to the values !! associated with the key in this one. generic :: update => update_map , update_multimap !! Update this multimap's contents with those of another !! (multi)map procedure ( remove_val_sub ), deferred :: remove_value !! Remove the specified value from the specified key end type multimap","tags":"","loc":"type/multimap.html","title":"multimap – FIAT "},{"text":"type, public, abstract, extends( dynamic_set ) :: multiset type~~multiset~~InheritsGraph type~multiset multiset type~dynamic_set dynamic_set type~dynamic_set->type~multiset type~data_set data_set type~data_set->type~dynamic_set type~countable countable type~countable->type~data_set type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for a multi-set data structure. These \n behave like a normal set, except they keep count of the number of\n times which an item has been added. When an item is removed, the\n count will be decremented by 1. The item will only become absent\n from the list ( has returns .false. ) when the count\n reaches zero. Type-Bound Procedures procedure( get_func ), public, deferred :: get Returns the number of times this item is present in the set. pure function get_func (this, item) Prototype Arguments Type Intent Optional Attributes Name class( multiset ), intent(in) :: this class(*), intent(in) :: item The item whose presence in the set is being checked Return Value integer The number of times this item appears in the set Source Code type , public , extends ( dynamic_set ), abstract :: multiset !* Author: Chris MacMackin !  Date: March 2016 !  License: LGPLv3 ! ! Provides an abstract type for a multi-set data structure. These ! behave like a normal set, except they keep count of the number of ! times which an item has been added. When an item is removed, the ! count will be decremented by 1. The item will only become absent ! from the list ([[data_set:has]] returns `.false.`) when the count ! reaches zero. ! contains procedure ( get_func ), deferred :: get !! Returns the number of times this item is present in the set. end type multiset","tags":"","loc":"type/multiset.html","title":"multiset – FIAT "},{"text":"type, public :: node type~~node~~InheritsGraph type~node node type~container container type~container->type~node contents Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An object which contains a container that can be set to have\n arbitrary contents. While of limited use on its own, various\n derived types exist which are extensions of this one exist and\n are used to build more complex data structures. It is not anticipated that the node type, or any types extending it,\n will be handled directly by end users of FIAT; they are meant for\n internal use within this package. Inherited By type~~node~~InheritedByGraph type~node node type~linked_node linked_node type~node->type~linked_node type~linked_node->type~linked_node next type~bidir_node bidir_node type~linked_node->type~bidir_node type~bidir_node->type~bidir_node prev Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: contents Contains the value held in this node. Type-Bound Procedures procedure, public, non_overridable :: has_contents Evaluates whether contents have been assigned to node. private elemental function has_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not a values has been assigned to the node. procedure, public, non_overridable :: get_contents Returns the value stored in the node. private pure function get_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description Author Chris MacMackin Date February 2016 An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. procedure, public, non_overridable :: set_contents Sets the value to be stored in the node. private subroutine set_contents (this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Author Chris MacMackin Date February 2016 Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. procedure, public, non_overridable :: unset_contents Removes the record of any value stored in the node. private subroutine unset_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Author Chris MacMackin Date February 2016 Deallocates the value stored within the  node. Source Code type , public :: node !* Author: Chris MacMackin !  Date: February 2016 ! ! An object which contains a container that can be set to have ! arbitrary contents. While of limited use on its own, various ! derived types exist which are extensions of this one exist and ! are used to build more complex data structures. ! ! It is not anticipated that the node type, or any types extending it, ! will be handled directly by end users of FIAT; they are meant for ! internal use within this package. ! private class ( container ), allocatable :: contents !! Contains the value held in this node. contains procedure , non_overridable :: has_contents !! Evaluates whether contents have been assigned to node. procedure , non_overridable :: get_contents !! Returns the value stored in the node. procedure , non_overridable :: set_contents !! Sets the value to be stored in the node. procedure , non_overridable :: unset_contents !! Removes the record of any value stored in the node. end type node","tags":"","loc":"type/node.html","title":"node – FIAT "},{"text":"type, public, abstract, extends( countable ) :: ordered type~~ordered~~InheritsGraph type~ordered ordered type~countable countable type~countable->type~ordered type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract type which is an ancestor for any data structure in\n which items are stored in a particular order. This means that \n the order in which items are placed in the structure will \n determine the order in which they are retrieved. Examples of data\n structures descending from this one are a [[stack]], queue , or list . Inherited By type~~ordered~~InheritedByGraph type~ordered ordered type~queue queue type~ordered->type~queue type~deque deque type~queue->type~deque type~list list type~deque->type~list type~array_list array_list type~list->type~array_list Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure( push_sub ), public, deferred :: push Place a new item in the data structure pure subroutine push_sub (this, item) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item Contents to be added to this data structure procedure( pop_func ), public, deferred :: pop Remove and return the next item from the data structure function pop_func (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item in the data structure, which has been removed procedure( peek_func ), public, deferred :: peek Return, but do not remove, the next item in the data structure pure function peek_func (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable The next item in the data structure procedure( blank_sub ), public, deferred :: clear Remove all contents from the data structure pure subroutine blank_sub (this) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this procedure( logical_return ), public, nopass, deferred :: is_fifo Indicates whether this is a first in first out or last in last\n out data type. pure function logical_return () Prototype Arguments None Return Value logical True if first in first out structure, false if last in \n first out procedure, private :: array_extend Add ( push ) the elements of an array to this data\n structure private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items The items to be added to this data structure Description Author Chris MacMackin Date February 2016 Adds the elements of an array to this object. procedure, private :: iterator_extend Add ([[ordered::push]]) the contents of an iterator to \n this data structure. private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterable ), intent(inout) :: items The iterable whose contents are to be added to this data\n structure. Description Author Chris MacMackin Date February 2016 Adds the contents of an iterable object to this data structure. generic, public :: extend => array_extend , iterator_extend Place multiple new items in the data structure private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items The items to be added to this data structure Description Author Chris MacMackin Date February 2016 Adds the elements of an array to this object. private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterable ), intent(inout) :: items The iterable whose contents are to be added to this data\n structure. Description Author Chris MacMackin Date February 2016 Adds the contents of an iterable object to this data structure. procedure( concat_func ), private, deferred :: concat Join this object with another ordered object, returning\n the result. The contents of the returned object are ordered\n such that applying pop until the structure is\n empty would provide items in the same order as calling pop until the first object is empty and then until\n the second object is empty. pure function concat_func (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs This object class( ordered ), intent(in) :: rhs The object being concatenated to this one Return Value class( ordered ),\n  allocatable The result of the concatenation generic, public :: operator(//) => concat Overloads the concatenation operator to join this object with\n another ordered object, returning the result. The contents\n of the returned object are ordered such that applying pop until the structure is empty would provide \n items in the same order as calling pop until the \n first object is empty and then until the second object is \n empty. pure function concat_func (lhs, rhs) Prototype Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs This object class( ordered ), intent(in) :: rhs The object being concatenated to this one Return Value class( ordered ),\n  allocatable The result of the concatenation Source Code type , extends ( countable ), abstract , public :: ordered !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract type which is an ancestor for any data structure in ! which items are stored in a particular order. This means that ! the order in which items are placed in the structure will ! determine the order in which they are retrieved. Examples of data ! structures descending from this one are a [[stack]], [[queue]], or ! [[list]]. ! contains procedure ( push_sub ), deferred :: push !! Place a new item in the data structure procedure ( pop_func ), deferred :: pop !! Remove and return the next item from the data structure procedure ( peek_func ), deferred :: peek !! Return, but do not remove, the next item in the data structure procedure ( blank_sub ), deferred :: clear !! Remove all contents from the data structure procedure ( logical_return ), nopass , deferred :: is_fifo !! Indicates whether this is a first in first out or last in last !! out data type. procedure , private :: array_extend !! Add ([[ordered:push]]) the elements of an array to this data !! structure procedure , private :: iterator_extend !! Add ([[ordered::push]]) the contents of an [[iterator]] to !! this data structure. generic :: extend => array_extend , iterator_extend !! Place multiple new items in the data structure procedure ( concat_func ), private , deferred :: concat !! Join this object with another [[ordered]] object, returning !! the result. The contents of the returned object are ordered !! such that applying [[ordered:pop]] until the structure is !! empty would provide items in the same order as calling !! [[ordered:pop]] until the first object is empty and then until !! the second object is empty. generic :: operator ( // ) => concat !! Overloads the concatenation operator to join this object with !! another [[ordered]] object, returning the result. The contents !! of the returned object are ordered such that applying !! [[ordered:pop]] until the structure is empty would provide !! items in the same order as calling [[ordered:pop]] until the !! first object is empty and then until the second object is !! empty. end type ordered","tags":"","loc":"type/ordered.html","title":"ordered – FIAT "},{"text":"type, public, abstract, extends( ordered ) :: queue type~~queue~~InheritsGraph type~queue queue type~ordered ordered type~ordered->type~queue type~countable countable type~countable->type~ordered type~iterable iterable type~iterable->type~countable Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. An abstract data type representing the queue structure. This is \n largely a placeholder type, in case some methods specific to queues\n are added at a later time. However, it does implement the is_fifo method. Inherited By type~~queue~~InheritedByGraph type~queue queue type~deque deque type~queue->type~deque type~list list type~deque->type~list type~array_list array_list type~list->type~array_list Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure, public, nopass :: is_fifo => queue_is_fifo Returns true, as queues are a first in first out data type. private pure function queue_is_fifo () Arguments None Return Value logical Description Author Chris MacMackin Date February 2016 Returns .true. , indicating that queues are a \"first in first \n out\" data structure. Source Code type , public , extends ( ordered ), abstract :: queue !* Author: Chris MacMackin !  Date: February 2016 ! ! An abstract data type representing the queue structure. This is ! largely a placeholder type, in case some methods specific to queues ! are added at a later time. However, it does implement the ! [[ordered:is_fifo]] method. ! private contains procedure , nopass :: is_fifo => queue_is_fifo !! Returns true, as queues are a first in first out data type. end type queue","tags":"","loc":"type/queue.html","title":"queue – FIAT "},{"text":"abstract interface public subroutine action_sub(item) Arguments Type Intent Optional Attributes Name class( container ), intent(inout) :: item A container object which is will be modified in some way Description An abstract interface for a procedure which will act on each\n  item in a list.","tags":"","loc":"interface/action_sub.html","title":"action_sub – FIAT"},{"text":"abstract interface private function guard(this, lhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical","tags":"","loc":"interface/guard.html","title":"guard – FIAT"},{"text":"abstract interface public pure function test_func(item) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item The item which is being evaluated Return Value logical Whether the item passes the test or not Description An abstract interface for a function which tests a container object in some way","tags":"","loc":"interface/test_func.html","title":"test_func – FIAT"},{"text":"abstract interface public pure function addition_func(item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 One of the items in the addition class( container ), intent(in) :: item2 The other item in the addition Return Value class( container ),\n  allocatable The sum, item1 + item2 Description Performs an addition operation on two container objects,\n  returning the result in a container.","tags":"","loc":"interface/addition_func.html","title":"addition_func – FIAT"},{"text":"abstract interface public pure function subtraction_func(item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 The item which the other is subtracted from class( container ), intent(in) :: item2 The item subtracted from the other Return Value real A real number, the absolute value of which represents the\n magnitude of the difference between item1 and item2 . Description An abstract interface for a procedure finding the difference\n between two items, item1 - item2 . Note that a procedure may\n satisfy both this abstract interface and comparison_func .","tags":"","loc":"interface/subtraction_func.html","title":"subtraction_func – FIAT"},{"text":"abstract interface public pure function comparison_func(item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 The first item in the comparison class( container ), intent(in) :: item2 The second item in the comparison Return Value real negative if item1 < item2 , 0 if item1 == item2 , positive \n if item1 > item2 Description An abstract interface for a procedure comparing two container objects. Note that a procedure may satisfy both\n this abstract interface and subtraction_func .","tags":"","loc":"interface/comparison_func.html","title":"comparison_func – FIAT"},{"text":"abstract interface private pure function size_func(this) Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer The number of items stored in this object.","tags":"","loc":"interface/size_func.html","title":"size_func – FIAT"},{"text":"abstract interface private pure function union_func(this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing all elements found in this one and the other","tags":"","loc":"interface/union_func.html","title":"union_func – FIAT"},{"text":"abstract interface private pure function intersect_func(this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value integer","tags":"","loc":"interface/intersect_func.html","title":"intersect_func – FIAT"},{"text":"abstract interface private pure function diff_func(this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in this one and not the other","tags":"","loc":"interface/diff_func.html","title":"diff_func – FIAT"},{"text":"abstract interface private pure function pure_diff_func(this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in one, but not both, of this\n set or the other set","tags":"","loc":"interface/pure_diff_func.html","title":"pure_diff_func – FIAT"},{"text":"abstract interface private pure function relation_func(this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true","tags":"","loc":"interface/relation_func.html","title":"relation_func – FIAT"},{"text":"abstract interface private pure function has_func(this, item) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item An item which may be contained in the set Return Value logical Whether item is present in this set","tags":"","loc":"interface/has_func.html","title":"has_func – FIAT"},{"text":"abstract interface private pure function empty_func(this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value logical .true. if this set contains no items","tags":"","loc":"interface/empty_func.html","title":"empty_func – FIAT"},{"text":"abstract interface private pure function peek_func(this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value class( container ),\n  allocatable An item contained within the set. Is unallocated if the set\n is empty.","tags":"","loc":"interface/peek_func.html","title":"peek_func – FIAT"},{"text":"abstract interface private pure function filter_func(this, test) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( data_set ),\n  allocatable Contains those items in this set for which test returns .true.","tags":"","loc":"interface/filter_func.html","title":"filter_func – FIAT"},{"text":"abstract interface private pure function enum_func(this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value type( array_list ) A list containing copies of all of the items in this set","tags":"","loc":"interface/enum_func.html","title":"enum_func – FIAT"},{"text":"abstract interface private pure function min_func(this, comparison) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the set, as determined by the comparison function","tags":"","loc":"interface/min_func.html","title":"min_func – FIAT"},{"text":"abstract interface private pure function max_func(this, comparison) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the set, as determined by the comparison function","tags":"","loc":"interface/max_func.html","title":"max_func – FIAT"},{"text":"abstract interface private pure function nearest_func(this, item, subtraction) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item The value which those in the set are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the set which, when passed to subtraction with item as the other argument, returns the smallest value","tags":"","loc":"interface/nearest_func.html","title":"nearest_func – FIAT"},{"text":"abstract interface private pure function sum_func(this, addition) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this set","tags":"","loc":"interface/sum_func.html","title":"sum_func – FIAT"},{"text":"abstract interface private pure subroutine push_sub(this, item) Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this class(*), intent(in) :: item The value to be added to the list","tags":"","loc":"interface/push_sub.html","title":"push_sub – FIAT"},{"text":"abstract interface private function pop_func(this) Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this Return Value class( container ),\n  allocatable The next value, which has just been removed","tags":"","loc":"interface/pop_func.html","title":"pop_func – FIAT"},{"text":"abstract interface private pure function peek_func(this) Arguments Type Intent Optional Attributes Name class( deque ), intent(in) :: this Return Value class( container ),\n  allocatable The next value, which is not removed","tags":"","loc":"interface/peek_func~2.html","title":"peek_func – FIAT"},{"text":"abstract interface private pure function keys_func(this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the keys in this dictionary","tags":"","loc":"interface/keys_func.html","title":"keys_func – FIAT"},{"text":"abstract interface private pure function values_func(this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the values in this dictionary,\n stored in the same order as their corresponding key would\n be were keys called","tags":"","loc":"interface/values_func.html","title":"values_func – FIAT"},{"text":"abstract interface private function set_func(this, key, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: this class(*), intent(in) :: key The key whose value is to be set class(*), intent(in) :: val The value to be assigned to the specified key Return Value real","tags":"","loc":"interface/set_func.html","title":"set_func – FIAT"},{"text":"abstract interface private pure function type_func(this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used to store this \n dictionary's keys or values.","tags":"","loc":"interface/type_func.html","title":"type_func – FIAT"},{"text":"abstract interface public pure subroutine single_sub(this, item) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set","tags":"","loc":"interface/single_sub.html","title":"single_sub – FIAT"},{"text":"abstract interface public pure subroutine multiple_sub(this, items) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set","tags":"","loc":"interface/multiple_sub.html","title":"multiple_sub – FIAT"},{"text":"abstract interface public pure subroutine iter_sub(this, items) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class( iterable ), intent(in) :: items An iterable containing items to add or remove from the set","tags":"","loc":"interface/iter_sub.html","title":"iter_sub – FIAT"},{"text":"abstract interface public pure subroutine clear_sub(this) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this","tags":"","loc":"interface/clear_sub.html","title":"clear_sub – FIAT"},{"text":"abstract interface public function pop_func(this) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this Return Value class( container ),\n  allocatable A random item which has been removed from the set","tags":"","loc":"interface/pop_func~2.html","title":"pop_func – FIAT"},{"text":"abstract interface private pure function iterator_return(this) Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value type( iterator ) An iterator with the contents of this object","tags":"","loc":"interface/iterator_return.html","title":"iterator_return – FIAT"},{"text":"abstract interface private pure function container_return(this) Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used in this object","tags":"","loc":"interface/container_return.html","title":"container_return – FIAT"},{"text":"abstract interface private subroutine append_sub(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list","tags":"","loc":"interface/append_sub.html","title":"append_sub – FIAT"},{"text":"abstract interface private subroutine set_single_sub(this, element, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element","tags":"","loc":"interface/set_single_sub.html","title":"set_single_sub – FIAT"},{"text":"abstract interface private subroutine set_multiple_sub(this, elements, items) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements .","tags":"","loc":"interface/set_multiple_sub.html","title":"set_multiple_sub – FIAT"},{"text":"abstract interface private subroutine foreach_sub(this, action) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list","tags":"","loc":"interface/foreach_sub.html","title":"foreach_sub – FIAT"},{"text":"abstract interface private subroutine insert_sub(this, position, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list","tags":"","loc":"interface/insert_sub.html","title":"insert_sub – FIAT"},{"text":"abstract interface private subroutine remove_sub(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list","tags":"","loc":"interface/remove_sub.html","title":"remove_sub – FIAT"},{"text":"abstract interface private subroutine remove_last_sub(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list","tags":"","loc":"interface/remove_last_sub.html","title":"remove_last_sub – FIAT"},{"text":"abstract interface private subroutine remove_all_sub(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list","tags":"","loc":"interface/remove_all_sub.html","title":"remove_all_sub – FIAT"},{"text":"abstract interface private subroutine delete_single_sub(this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list","tags":"","loc":"interface/delete_single_sub.html","title":"delete_single_sub – FIAT"},{"text":"abstract interface private subroutine delete_multiple_sub(this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list","tags":"","loc":"interface/delete_multiple_sub.html","title":"delete_multiple_sub – FIAT"},{"text":"abstract interface private subroutine delete_slice_sub(this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted","tags":"","loc":"interface/delete_slice_sub.html","title":"delete_slice_sub – FIAT"},{"text":"abstract interface private subroutine sort_sub(this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another","tags":"","loc":"interface/sort_sub.html","title":"sort_sub – FIAT"},{"text":"abstract interface private pure function get_func(this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element","tags":"","loc":"interface/get_func.html","title":"get_func – FIAT"},{"text":"abstract interface private pure function get_index_func(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list","tags":"","loc":"interface/get_index_func.html","title":"get_index_func – FIAT"},{"text":"abstract interface private pure function get_last_index_func(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list","tags":"","loc":"interface/get_last_index_func.html","title":"get_last_index_func – FIAT"},{"text":"abstract interface private pure function get_indices_func(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list","tags":"","loc":"interface/get_indices_func.html","title":"get_indices_func – FIAT"},{"text":"abstract interface private function slice_func(this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable A list containing the elements within the slice.","tags":"","loc":"interface/slice_func.html","title":"slice_func – FIAT"},{"text":"abstract interface private elemental function has_func(this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise","tags":"","loc":"interface/has_func~2.html","title":"has_func – FIAT"},{"text":"abstract interface private pure function min_func(this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function","tags":"","loc":"interface/min_func~2.html","title":"min_func – FIAT"},{"text":"abstract interface private pure function max_func(this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function","tags":"","loc":"interface/max_func~2.html","title":"max_func – FIAT"},{"text":"abstract interface private pure function nearest_func(this, item, subtraction) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value","tags":"","loc":"interface/nearest_func~2.html","title":"nearest_func – FIAT"},{"text":"abstract interface private pure function sum_func(this, addition) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list","tags":"","loc":"interface/sum_func~2.html","title":"sum_func – FIAT"},{"text":"abstract interface private pure function filter_func(this, test) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true.","tags":"","loc":"interface/filter_func~2.html","title":"filter_func – FIAT"},{"text":"abstract interface private pure function to_array_func(this) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list","tags":"","loc":"interface/to_array_func.html","title":"to_array_func – FIAT"},{"text":"abstract interface private pure subroutine update_sub(this, other) Arguments Type Intent Optional Attributes Name class( map ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n overwriting as necessary.","tags":"","loc":"interface/update_sub.html","title":"update_sub – FIAT"},{"text":"abstract interface private pure function get_func(this, key) Arguments Type Intent Optional Attributes Name class( map ), intent(in) :: this class(*), intent(in) :: key The key whose associated value is to be returned Return Value class( container ),\n  allocatable The value associated with the specified key","tags":"","loc":"interface/get_func~2.html","title":"get_func – FIAT"},{"text":"abstract interface private pure subroutine update_multimap_sub(this, other) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( multimap ), intent(in) :: other A multimap whose key-value pairs will be added to this one,\n adding values to any keys which already exist in this one.","tags":"","loc":"interface/update_multimap_sub.html","title":"update_multimap_sub – FIAT"},{"text":"abstract interface private pure subroutine update_map_sub(this, other) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n appending the value to any keys which already exist in this\n one.","tags":"","loc":"interface/update_map_sub.html","title":"update_map_sub – FIAT"},{"text":"abstract interface private pure subroutine remove_val_sub(this, key, val) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class(*), intent(in) :: key A key from which to remove a value class(*), intent(in) :: val A value which will be removed from key , if key has such\n a value.","tags":"","loc":"interface/remove_val_sub.html","title":"remove_val_sub – FIAT"},{"text":"abstract interface private pure function get_func(this, key) Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be returned Return Value type( array_list ) The values associated with the specified key","tags":"","loc":"interface/get_func~3.html","title":"get_func – FIAT"},{"text":"abstract interface private pure function get_count_func(this, key) Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be counted Return Value real","tags":"","loc":"interface/get_count_func.html","title":"get_count_func – FIAT"},{"text":"abstract interface private pure function get_func(this, item) Arguments Type Intent Optional Attributes Name class( multiset ), intent(in) :: this class(*), intent(in) :: item The item whose presence in the set is being checked Return Value integer The number of times this item appears in the set","tags":"","loc":"interface/get_func~4.html","title":"get_func – FIAT"},{"text":"abstract interface private pure subroutine push_sub(this, item) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item Contents to be added to this data structure","tags":"","loc":"interface/push_sub~2.html","title":"push_sub – FIAT"},{"text":"abstract interface private pure subroutine blank_sub(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this","tags":"","loc":"interface/blank_sub.html","title":"blank_sub – FIAT"},{"text":"abstract interface private function pop_func(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item in the data structure, which has been removed","tags":"","loc":"interface/pop_func~3.html","title":"pop_func – FIAT"},{"text":"abstract interface private pure function peek_func(this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable The next item in the data structure","tags":"","loc":"interface/peek_func~3.html","title":"peek_func – FIAT"},{"text":"abstract interface private pure function logical_return() Arguments None Return Value logical True if first in first out structure, false if last in \n first out","tags":"","loc":"interface/logical_return.html","title":"logical_return – FIAT"},{"text":"abstract interface private pure function concat_func(lhs, rhs) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs This object class( ordered ), intent(in) :: rhs The object being concatenated to this one Return Value class( ordered ),\n  allocatable The result of the concatenation","tags":"","loc":"interface/concat_func.html","title":"concat_func – FIAT"},{"text":"private pure function contents(this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Returns the contents, encoded as a character array, of the \n container. Source Code pure function contents ( this ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Returns the contents, encoded as a character array, of the !! container. class ( container ), intent ( in ) :: this integer ( i1 ), dimension (:), allocatable :: contents contents = this % storage end function contents","tags":"","loc":"proc/contents.html","title":"contents – FIAT"},{"text":"private elemental function is_filled(this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value logical Description Returns .true. if a value has been assigned to the container, .false. otherwise. Source Code elemental logical function is_filled ( this ) !! Author: Chris MacMackin !! Date: March 2016 !! !! Returns `.true.` if a value has been assigned to the container, !! `.false.` otherwise. class ( container ), intent ( in ) :: this is_filled = this % filled end function is_filled","tags":"","loc":"proc/is_filled.html","title":"is_filled – FIAT"},{"text":"private elemental function is_equal(lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Checks whether two containers are of the same type and are\n storing the same contents. Source Code elemental logical function is_equal ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Checks whether two containers are of the same type and are !! storing the same contents. class ( container ), intent ( in ) :: lhs , rhs if (. not . same_type_as ( lhs , rhs )) then is_equal = . false . return end if if ((. not . lhs % filled ). and .(. not . rhs % filled )) then is_equal = . true . return end if if ( lhs % filled . neqv . rhs % filled ) then is_equal = . false . return end if is_equal = ( size ( lhs % storage ) == size ( rhs % storage ) . and . & all ( lhs % storage == rhs % storage )) end function is_equal","tags":"","loc":"proc/is_equal.html","title":"is_equal – FIAT"},{"text":"private subroutine assign_container(lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. Source Code subroutine assign_container ( lhs , rhs ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the contents of the container to another variable. !! If the other variable is another container of the same type !! then the contents will be transferred. If the other variable is !! the same type as the contents of the container (as determined !! by the [[container:typeguard]] routine provided for that !! concrete type extension) then it will be given the value held by !! the container. Otherwise, an error message will be printed and !! the program stopped. If compiled with `gfortran` then a backtrace !! will also be printed. In the event that the container was never !! set to a value, then this also constitutes an error. class ( * ), intent ( inout ) :: lhs !! The variable which the container contents will be assigned to. class ( container ), intent ( in ) :: rhs !! The container variable. !------------------------------------------------------------------- select type ( lhs ) class is ( container ) if ( same_type_as ( lhs , rhs )) then if ( rhs % filled ) then lhs % storage = rhs % storage lhs % filled = . true . else if ( lhs % filled ) then deallocate ( lhs % storage ) lhs % filled = . false . end if return else write ( stderr , * ) \"ERROR: Can not assign to a different container subclass\" #ifdef __GFORTRAN__ call backtrace #endif stop end if class default if ( rhs % filled ) then if ( rhs % typeguard ( lhs )) return write ( stderr , * ) \"ERROR: Can not assign this container's contents to given variable\" #ifdef __GFORTRAN__ call backtrace #endif stop else write ( stderr , * ) \"ERROR: Container is empty.\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end select end subroutine assign_container","tags":"","loc":"proc/assign_container.html","title":"assign_container – FIAT"},{"text":"private subroutine set(this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed. Warning During the initial phase of writing unit tests for the \n containers, I found that when content is class(container) then\n ~5GB of memory would end up being allocated when allocating tmp.\n After various experiments, I found that changing where tmp is\n allocated, so that this is only done if it is not being allocated\n to another container type, stopped this from happening. However,\n I'm still not clear on exactly what the cause of the bug is \n (similar things occasionally happened when DEallocating a \n container) and suspect its origin is a compiler bug. As such, I'm\n keeping this note here for information in case the issue ever\n arises again. Variables Type Visibility Attributes Name Initial class(*), public, allocatable :: tmp Source Code subroutine set ( this , content ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Sets the contents of the storage array to value passed. The type !! of the variable provided must be the same as the container !! variable is designed to accept (as determined by the !! concrete type implementation of the [[container:typeguard]] !! method in the extension) or be of the same type of container. !! Otherwise an error message will be printed and the program will !! exit. If `gfortran` was used to compile then a backtrace will !! also be printed. !! !! @Warning During the initial phase of writing unit tests for the !! containers, I found that when content is class(container) then !! ~5GB of memory would end up being allocated when allocating tmp. !! After various experiments, I found that changing where tmp is !! allocated, so that this is only done if it is not being allocated !! to another container type, stopped this from happening. However, !! I'm still not clear on exactly what the cause of the bug is !! (similar things occasionally happened when DEallocating a !! container) and suspect its origin is a compiler bug. As such, I'm !! keeping this note here for information in case the issue ever !! arises again. !! class ( container ), intent ( out ) :: this class ( * ), intent ( in ) :: content !! The value to be placed in the container class ( * ), allocatable :: tmp if (. not . allocated ( this % storage )) allocate ( this % storage ( 1 )) if ( same_type_as ( this , content )) then select type ( content ) class is ( container ) if ( content % filled ) then this % filled = . true . this % storage = content % storage else this % filled = . false . deallocate ( this % storage ) endif return end select end if allocate ( tmp , source = content ) if ( this % typeguard ( tmp )) then this % filled = . true . this % storage = transfer ( content , this % storage ) else write ( stderr , * ) \"ERROR: Can not assign given variable to this container\" #ifdef __GFORTRAN__ call backtrace #endif stop end if end subroutine set","tags":"","loc":"proc/set.html","title":"set – FIAT"},{"text":"private pure function array_list_iter(this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value type( iterator ) Description Returns an iterator containing the contents of this list\n as they were at the time this method was called. Source Code pure type ( iterator ) function array_list_iter ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an [[iterator]] containing the contents of this list ! as they were at the time this method was called. ! class ( array_list ), intent ( in ) :: this end function array_list_iter","tags":"","loc":"proc/array_list_iter.html","title":"array_list_iter – FIAT"},{"text":"private pure function array_list_contents_type(this) result(cont) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable Description Returns a container with the dynamic type of the contents of this\n list. Source Code pure function array_list_contents_type ( this ) result ( cont ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a container with the dynamic type of the contents of this ! list. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: cont end function array_list_contents_type","tags":"","loc":"proc/array_list_contents_type.html","title":"array_list_contents_type – FIAT"},{"text":"private pure function array_list_size(this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value integer Description Returns the number of items in the list Source Code pure integer function array_list_size ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the number of items in the list ! class ( array_list ), intent ( in ) :: this end function array_list_size","tags":"","loc":"proc/array_list_size.html","title":"array_list_size – FIAT"},{"text":"private function array_list_pop(this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The value from the end of the list Description Removes the item at the end of the list and returns it. Source Code function array_list_pop ( this ) result ( pop ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the item at the end of the list and returns it. ! class ( array_list ), intent ( inout ) :: this class ( container ), allocatable :: pop !! The value from the end of the list end function array_list_pop","tags":"","loc":"proc/array_list_pop.html","title":"array_list_pop – FIAT"},{"text":"private pure function array_list_peek(this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The element at the end of the list Description Returns the item at the end of the list, without removing it. Source Code pure function array_list_peek ( this ) result ( peek ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the end of the list, without removing it. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: peek !! The element at the end of the list end function array_list_peek","tags":"","loc":"proc/array_list_peek.html","title":"array_list_peek – FIAT"},{"text":"private pure function array_list_concat(lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: lhs The list class( ordered ), intent(in) :: rhs The object being concatenated to the list Return Value class( ordered ),\n  allocatable The concatenated object. Will have dynamic type array_list . Description Join this list with an ordered object, returning the result. The \n contents of the returned object are ordered such that applying pop until it is empty would return items in the same order as \n calling pop until the list is empty and then until the second \n object is empty. Source Code pure function array_list_concat ( lhs , rhs ) result ( concat ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Join this list with an [[ordered]] object, returning the result. The ! contents of the returned object are ordered such that applying ! [[ordered:pop]] until it is empty would return items in the same order as ! calling [[ordered:pop]] until the list is empty and then until the second ! object is empty. ! class ( array_list ), intent ( in ) :: lhs !! The list class ( ordered ), intent ( in ) :: rhs !! The object being concatenated to the list class ( ordered ), allocatable :: concat !! The concatenated object. Will have dynamic type [[array_list]]. end function array_list_concat","tags":"","loc":"proc/array_list_concat.html","title":"array_list_concat – FIAT"},{"text":"private function array_list_popleft(this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The item just removed from the start of the list Description Removes the item at the start of the list and returns it. Source Code function array_list_popleft ( this ) result ( pop ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the item at the start of the list and returns it. ! class ( array_list ), intent ( inout ) :: this class ( container ), allocatable :: pop !! The item just removed from the start of the list end function array_list_popleft","tags":"","loc":"proc/array_list_popleft.html","title":"array_list_popleft – FIAT"},{"text":"private pure function array_list_peekleft(this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The item at the start of the list Description Returns the item at the start of the list. Source Code pure function array_list_peekleft ( this ) result ( peek ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the start of the list. ! class ( array_list ), intent ( in ) :: this class ( container ), allocatable :: peek !! The item at the start of the list end function array_list_peekleft","tags":"","loc":"proc/array_list_peekleft.html","title":"array_list_peekleft – FIAT"},{"text":"private pure function array_list_get(this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element . Unallocated if no such element\n is present. Description Returns the item at the specified location in the list. Returns\n an unallocated container if that location has not been set. Source Code pure function array_list_get ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the item at the specified location in the list. Returns ! an unallocated container if that location has not been set. ! class ( array_list ), intent ( in ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element to return class ( container ), allocatable :: array_list_get !! The item with index `element`. Unallocated if no such element !! is present. end function array_list_get","tags":"","loc":"proc/array_list_get.html","title":"array_list_get – FIAT"},{"text":"private pure function array_list_get_index(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list Description Returns the index of the first occurrence of the item in the list.\n If there are no occurrences, then returns -1. Source Code pure function array_list_get_index ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the index of the first occurrence of the item in the list. ! If there are no occurrences, then returns -1. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: array_list_get_index !! Position of the first occurrence of `item` in list end function array_list_get_index","tags":"","loc":"proc/array_list_get_index.html","title":"array_list_get_index – FIAT"},{"text":"private pure function array_list_get_last_index(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list. -1 if item not present Description Returns the index of the last occurrence of the item in the list.\n If there are no occurrences, then returns -1. Source Code pure function array_list_get_last_index ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the index of the last occurrence of the item in the list. ! If there are no occurrences, then returns -1. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer :: array_list_get_last_index !! Position of the last occurrence of `item` in list. -1 if `item` !! not present end function array_list_get_last_index","tags":"","loc":"proc/array_list_get_last_index.html","title":"array_list_get_last_index – FIAT"},{"text":"private pure function array_list_get_indices(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list. Unallocated\n if item not present. Description Returns an array containing the indices of all occurrences of the\n item in the list. If there are no occurrences, then returns an\n unallocated array. Source Code pure function array_list_get_indices ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an array containing the indices of all occurrences of the ! item in the list. If there are no occurrences, then returns an ! unallocated array. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item integer , dimension (:), allocatable :: array_list_get_indices !! Positions of the all occurrences of `item` in list. Unallocated !! if `item` not present. end function array_list_get_indices","tags":"","loc":"proc/array_list_get_indices.html","title":"array_list_get_indices – FIAT"},{"text":"private function array_list_slice(this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable An array_list containing the elements within the slice. Description Returns an array_list instance containing all items in this\n list within the specified slice, inclusive. Crashes if one of\n the indices is outside of the list's bounds. Source Code function array_list_slice ( this , start_element , end_element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns an [[array_list]] instance containing all items in this ! list within the specified slice, inclusive. Crashes if one of ! the indices is outside of the list's bounds. ! class ( array_list ), intent ( in ) :: this integer , intent ( in ) :: start_element !! The index of the first element in the slice to be returned integer , intent ( in ) :: end_element !! The index of the last element in the slice to be returned class ( list ), allocatable :: array_list_slice !! An array_list containing the elements within the slice. end function array_list_slice","tags":"","loc":"proc/array_list_slice.html","title":"array_list_slice – FIAT"},{"text":"private elemental function array_list_has(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise Description Indicates whether there are any copies of the specified item\n present in the list. Source Code elemental function array_list_has ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Indicates whether there are any copies of the specified item ! present in the list. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! A value whose presence in the list is being checked for logical :: array_list_has !! `.true.` if `item` is present in list, `.false.` otherwise end function array_list_has","tags":"","loc":"proc/array_list_has.html","title":"array_list_has – FIAT"},{"text":"private pure function array_list_min(this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function Description Returns the smallest item contained in the list, as determined\n using the provided comparison function. Source Code pure function array_list_min ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the smallest item contained in the list, as determined ! using the provided comparison function. ! class ( array_list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: array_list_min !! The smallest item in the list, as determined by the !! `comparison` function end function array_list_min","tags":"","loc":"proc/array_list_min.html","title":"array_list_min – FIAT"},{"text":"private pure function array_list_max(this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function Description Returns the largest item contained in the list, as determined\n using the provided comparison function. Source Code pure function array_list_max ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the largest item contained in the list, as determined ! using the provided comparison function. ! class ( array_list ), intent ( in ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another class ( container ), allocatable :: array_list_max !! The largest item in the list, as determined by the !! `comparison` function end function array_list_max","tags":"","loc":"proc/array_list_max.html","title":"array_list_max – FIAT"},{"text":"private pure function array_list_nearest(this, item, subtraction) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value Description Returns the value contained in the list for which the subtraction\n function returns the smallest absolute real number when comparing\n with the specified item . Source Code pure function array_list_nearest ( this , item , subtraction ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the value contained in the list for which the subtraction ! function returns the smallest absolute real number when comparing ! with the specified `item`. ! class ( array_list ), intent ( in ) :: this class ( * ), intent ( in ) :: item !! The value which those in the list are being compared to procedure ( subtraction_func ) :: subtraction !! A function determining the magnitude of the difference !! between two items class ( container ), allocatable :: array_list_nearest !! The value from the list which, when passed to `subtraction` !! with `item` as the other argument, returns the smallest value end function array_list_nearest","tags":"","loc":"proc/array_list_nearest.html","title":"array_list_nearest – FIAT"},{"text":"private pure function array_list_sum(this, addition) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list Description Returns a container representing the sum of all items \n contained in the list. This sum is calculated by repeatedly\n applying the addition procedure to the list's contents. Source Code pure function array_list_sum ( this , addition ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a [[container]] representing the sum of all items ! contained in the list. This sum is calculated by repeatedly ! applying the addition procedure to the list's contents. ! class ( array_list ), intent ( in ) :: this procedure ( addition_func ) :: addition !! A procedure performing addition between two [[container]] !! objects and returning the result in another container class ( container ), allocatable :: array_list_sum !! A container holding the sum of all of the items held within !! this list end function array_list_sum","tags":"","loc":"proc/array_list_sum.html","title":"array_list_sum – FIAT"},{"text":"private pure function array_list_filter(this, test) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true. Description Returns a new list containing only those items held in this list\n which pass the provided test. Source Code pure function array_list_filter ( this , test ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a new list containing only those items held in this list ! which pass the provided test. ! class ( array_list ), intent ( in ) :: this procedure ( test_func ) :: test !! A test for which the values that pass will be returned in a !! new list class ( list ), allocatable :: array_list_filter !! Contains those items in this list for which `test` returns !! `.true.` end function array_list_filter","tags":"","loc":"proc/array_list_filter.html","title":"array_list_filter – FIAT"},{"text":"private pure function array_list_to_array(this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list Description Returns copies of all items held in this list, stored within an\n array of container objects. Source Code pure function array_list_to_array ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns copies of all items held in this list, stored within an ! array of [[container]] objects. ! class ( array_list ), intent ( in ) :: this class ( container ), dimension (:), allocatable :: array_list_to_array !! An array of [[container]] objects holding the contents of !! this list end function array_list_to_array","tags":"","loc":"proc/array_list_to_array.html","title":"array_list_to_array – FIAT"},{"text":"private pure subroutine array_list_push(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item The value to place at the start of the list. Description Adds an item to the beginning of the list. Source Code pure subroutine array_list_push ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Adds an item to the beginning of the list. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! The value to place at the start of the list. end subroutine array_list_push","tags":"","loc":"proc/array_list_push.html","title":"array_list_push – FIAT"},{"text":"private pure subroutine array_list_clear(this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Description Removes all items from this list, but does not change its container type. Source Code pure subroutine array_list_clear ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes all items from this list, but does not change its container type. ! class ( array_list ), intent ( inout ) :: this end subroutine array_list_clear","tags":"","loc":"proc/array_list_clear.html","title":"array_list_clear – FIAT"},{"text":"private pure subroutine array_list_append(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list Description Adds the provided item to the end of the list. Source Code pure subroutine array_list_append ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Adds the provided item to the end of the list. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! Item to be appended to list end subroutine array_list_append","tags":"","loc":"proc/array_list_append.html","title":"array_list_append – FIAT"},{"text":"private subroutine array_list_set_single(this, element, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element Description Places the value of the provided element in the specified location\n in the array. Crashes if this element is not already defined. Source Code subroutine array_list_set_single ( this , element , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the value of the provided element in the specified location ! in the array. Crashes if this element is not already defined. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The index (starting from 1) of the element whose value is to be set. class ( * ), intent ( in ) :: item !! The value to store in the specified element end subroutine array_list_set_single","tags":"","loc":"proc/array_list_set_single.html","title":"array_list_set_single – FIAT"},{"text":"private subroutine array_list_set_multiple(this, elements, items) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . Description Places the values of the provided array of items in the locations\n specified by the corresponding indices in the in the array of\n elements. Source Code subroutine array_list_set_multiple ( this , elements , items ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the values of the provided array of items in the locations ! specified by the corresponding indices in the in the array of ! elements. ! class ( array_list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: elements !! The indices (starting from 1) of the elements whose values !! are to be set. class ( * ), dimension (:), intent ( in ) :: items !! The values to be stored in the specified elements. Each item !! is placed in the element specified by the integer in the !! corresponding position in the array `elements`. end subroutine array_list_set_multiple","tags":"","loc":"proc/array_list_set_multiple.html","title":"array_list_set_multiple – FIAT"},{"text":"private subroutine array_list_foreach(this, action) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list Description Performs the specified action on each item in the list, in place. Source Code subroutine array_list_foreach ( this , action ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Performs the specified action on each item in the list, in place. ! class ( array_list ), intent ( inout ) :: this procedure ( action_sub ) :: action !! A procedure to act on each element of the list end subroutine array_list_foreach","tags":"","loc":"proc/array_list_foreach.html","title":"array_list_foreach – FIAT"},{"text":"private subroutine array_list_insert(this, position, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list Description Places the provided item into the list at the position specified,\n moving all succeeding items forward by one. The position must be\n one which is already filled or the length of the list plus one. Source Code subroutine array_list_insert ( this , position , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Places the provided item into the list at the position specified, ! moving all succeeding items forward by one. The position must be ! one which is already filled or the length of the list plus one. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: position !! The location at which the new element will be placed class ( * ), intent ( in ) :: item !! The value to be placed in the list end subroutine array_list_insert","tags":"","loc":"proc/array_list_insert.html","title":"array_list_insert – FIAT"},{"text":"private subroutine array_list_remove(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list Description Remove the first occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. Source Code subroutine array_list_remove ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove the first occurrence of the specified item from the list, ! moving all succeeding items back by one position. No action is ! taken if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the first occurrence of which will be removed from !! the list end subroutine array_list_remove","tags":"","loc":"proc/array_list_remove.html","title":"array_list_remove – FIAT"},{"text":"private subroutine array_list_remove_last(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list Description Remove the last occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. Source Code subroutine array_list_remove_last ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove the last occurrence of the specified item from the list, ! moving all succeeding items back by one position. No action is ! taken if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, the last occurrence of which will be removed from !! the list end subroutine array_list_remove_last","tags":"","loc":"proc/array_list_remove_last.html","title":"array_list_remove_last – FIAT"},{"text":"private subroutine array_list_remove_all(this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list Description Remove all occurrences of the specified item from the list,\n moving all succeeding items back in position. No action is taken\n if the item is not present. Source Code subroutine array_list_remove_all ( this , item ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Remove all occurrences of the specified item from the list, ! moving all succeeding items back in position. No action is taken ! if the item is not present. ! class ( array_list ), intent ( inout ) :: this class ( * ), intent ( in ) :: item !! An item, all occurrences of which will be removed from the !! list end subroutine array_list_remove_all","tags":"","loc":"proc/array_list_remove_all.html","title":"array_list_remove_all – FIAT"},{"text":"private subroutine array_list_delete_single(this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list Description Removes the element at the specified position in the list, moving\n all succeeding items back by one position. Crashes if the element\n has not been set. Source Code subroutine array_list_delete_single ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the element at the specified position in the list, moving ! all succeeding items back by one position. Crashes if the element ! has not been set. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: element !! The position of the element to be deleted from the list end subroutine array_list_delete_single","tags":"","loc":"proc/array_list_delete_single.html","title":"array_list_delete_single – FIAT"},{"text":"private subroutine array_list_delete_multiple(this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list Description Removes the elements at the positions specified by the indices in\n the array elements from the list. The elements removed are those\n at the specified location just before the call was made. Once all\n removals have been performed, the remaining elements well be moved\n backwards in position as necessary. Crashes if an element has not\n been set. Source Code subroutine array_list_delete_multiple ( this , element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the elements at the positions specified by the indices in ! the array `elements` from the list. The elements removed are those ! at the specified location just before the call was made. Once all ! removals have been performed, the remaining elements well be moved ! backwards in position as necessary. Crashes if an element has not ! been set. ! class ( array_list ), intent ( inout ) :: this integer , dimension (:), intent ( in ) :: element !! The positions of the elements to be deleted from the list end subroutine array_list_delete_multiple","tags":"","loc":"proc/array_list_delete_multiple.html","title":"array_list_delete_multiple – FIAT"},{"text":"private subroutine array_list_delete_slice(this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted Description Removes the element within the specified slice of the list, moving\n all succeeding items back by the number of items deleted. The \n slice contains the element at the start index to the end index,\n inclusive. Crashes if part of the slice has not been set. Source Code subroutine array_list_delete_slice ( this , start_element , end_element ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Removes the element within the specified slice of the list, moving ! all succeeding items back by the number of items deleted. The ! slice contains the element at the start index to the end index, ! inclusive. Crashes if part of the slice has not been set. ! class ( array_list ), intent ( inout ) :: this integer , intent ( in ) :: start_element !! Index of the first element in the slice to be deleted integer , intent ( in ) :: end_element !! Index of the last element in the slice to be deleted end subroutine array_list_delete_slice","tags":"","loc":"proc/array_list_delete_slice.html","title":"array_list_delete_slice – FIAT"},{"text":"private subroutine array_list_sort(this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Description Sorts the list, in place, so that all items are in ascending order\n according the the provided comparison function. Source Code subroutine array_list_sort ( this , comparison ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Sorts the list, in place, so that all items are in ascending order ! according the the provided comparison function. ! class ( array_list ), intent ( inout ) :: this procedure ( comparison_func ) :: comparison !! A procedure which evaluates whether a [[container]] object is !! less than, equal to, or greater than another end subroutine array_list_sort","tags":"","loc":"proc/array_list_sort.html","title":"array_list_sort – FIAT"},{"text":"private elemental function has_prev(this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. Source Code elemental logical function has_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points to a previous one, forming ! a chain in the backwards direction. ! class ( bidir_node ), intent ( in ) :: this has_prev = associated ( this % prev ) end function has_prev","tags":"","loc":"proc/has_prev.html","title":"has_prev – FIAT"},{"text":"private function get_prev(this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. Source Code function get_prev ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the previous node in the chain. If this node ! does not point at a previous one one, then a null pointer is ! returned. ! class ( bidir_node ), intent ( in ) :: this class ( bidir_node ), pointer :: get_prev if ( this % has_prev ()) then get_prev => this % prev else get_prev => null () end if end function get_prev","tags":"","loc":"proc/get_prev.html","title":"get_prev – FIAT"},{"text":"private subroutine set_prev(this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. Source Code subroutine set_prev ( this , new_prev , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the pointer to the previous node in the chain. If this node ! already points to a previous one, the pointer will, by default, be ! nullified. This may result in a memory leak. Optionally, by ! setting `deallocate_old=.true.`, the previous node (and all nodes ! it points to) can be deallocated. This may result in a segfault if ! another part of the program tries to access the former previous ! node. The new previous node will not automatically be set to have ! this one as the next, with the same rules applied to deallocation. ! class ( bidir_node ), intent ( inout ) :: this class ( bidir_node ), pointer , intent ( in ) :: new_prev !! The node which will now be previous in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! previous nodes in the chain. Defaults to `.false.`. call this % unset_prev ( deallocate_old ) this % prev => new_prev end subroutine set_prev","tags":"","loc":"proc/set_prev.html","title":"set_prev – FIAT"},{"text":"private subroutine unset_prev(this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node. Source Code subroutine unset_prev ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the previous node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! previous node (and all previous nodes it points to) can be ! deallocated. This may result in a segfault if another part of the ! program tries to access the former previous node. ! class ( bidir_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! p nodes in the chain. Defaults to `.false.`. if (. not . this % has_prev ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % prev % unset_prev (. true .) deallocate ( this % prev ) return end if end if nullify ( this % prev ) end subroutine unset_prev","tags":"","loc":"proc/unset_prev.html","title":"unset_prev – FIAT"},{"text":"private function int_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int_guard","tags":"","loc":"proc/int_guard.html","title":"int_guard – FIAT"},{"text":"private function int1_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int1_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int1_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i1 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int1_guard","tags":"","loc":"proc/int1_guard.html","title":"int1_guard – FIAT"},{"text":"private function int2_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int2_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int2_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i2 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int2_guard","tags":"","loc":"proc/int2_guard.html","title":"int2_guard – FIAT"},{"text":"private function int4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int4_guard","tags":"","loc":"proc/int4_guard.html","title":"int4_guard – FIAT"},{"text":"private function int8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function int8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( int8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( integer ( i8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function int8_guard","tags":"","loc":"proc/int8_guard.html","title":"int8_guard – FIAT"},{"text":"private function real_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real_guard","tags":"","loc":"proc/real_guard.html","title":"real_guard – FIAT"},{"text":"private function real4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real4_guard","tags":"","loc":"proc/real4_guard.html","title":"real4_guard – FIAT"},{"text":"private function real8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real8_guard","tags":"","loc":"proc/real8_guard.html","title":"real8_guard – FIAT"},{"text":"private function real16_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function real16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( real16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( real ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function real16_guard","tags":"","loc":"proc/real16_guard.html","title":"real16_guard – FIAT"},{"text":"private function complex_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex_guard","tags":"","loc":"proc/complex_guard.html","title":"complex_guard – FIAT"},{"text":"private function complex4_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex4_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex4_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r4 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex4_guard","tags":"","loc":"proc/complex4_guard.html","title":"complex4_guard – FIAT"},{"text":"private function complex8_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex8_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex8_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r8 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex8_guard","tags":"","loc":"proc/complex8_guard.html","title":"complex8_guard – FIAT"},{"text":"private function complex16_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function complex16_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( complex16_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( complex ( r16 )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function complex16_guard","tags":"","loc":"proc/complex16_guard.html","title":"complex16_guard – FIAT"},{"text":"private function logical_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function logical_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( logical_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( logical ) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function logical_guard","tags":"","loc":"proc/logical_guard.html","title":"logical_guard – FIAT"},{"text":"private function character_guard(this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. Source Code logical function character_guard ( this , lhs ) result ( ret ) !! Author: Chris MacMackin !! Date: December 2015 !! !! Transfers the container's contents to the variable on the left !! hand side of the equals sign if it is of the correct type. class ( character_container ), intent ( in ) :: this class ( * ), intent ( inout ) :: lhs select type ( lhs ) type is ( character ( len =* )) lhs = transfer ( this % contents (), lhs ) ret = . true . class default ret = . false . end select end function character_guard","tags":"","loc":"proc/character_guard.html","title":"character_guard – FIAT"},{"text":"private pure function constructor(contents) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in), dimension(:) :: contents Return Value type( iterator ) Description Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last. Called By proc~~constructor~~CalledByGraph proc~constructor constructor interface~iterator iterator interface~iterator->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function constructor ( contents ) result ( new ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Creates an iterator from an array of containers containing ! the data to be returned upon iteration. The data is returned ! starting with the first element of the array and ending with ! the last. ! class ( container ), dimension (:), intent ( in ) :: contents type ( iterator ) :: new allocate ( new % contents ( size ( contents )), source = contents ) new % filled = . true . end function constructor","tags":"","loc":"proc/constructor.html","title":"constructor – FIAT"},{"text":"private elemental function has_next(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical Whether there are additional items to iterate through Description Returns .true. if there are any remaining objects through which\n to iterate, and .false. otherwise. Source Code elemental function has_next ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns `.true.` if there are any remaining objects through which ! to iterate, and `.false.` otherwise. ! class ( iterator ), intent ( in ) :: this logical :: has_next !! Whether there are additional items to iterate through has_next = this % location <= size ( this % contents ) end function has_next","tags":"","loc":"proc/has_next.html","title":"has_next – FIAT"},{"text":"private function next(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item held in the iterator, if present. Otherwise\n an unallocated container. Description Returns the next item stored in the iterator. If there are no\n more items present then an empty container is returned. If\n there are no contents stored in this iterator then it returns\n an unallocated container . Source Code function next ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns the next item stored in the iterator. If there are no ! more items present then an empty [[container]] is returned. If ! there are no contents stored in this iterator then it returns ! an unallocated [[container]]. ! class ( iterator ), intent ( inout ) :: this class ( container ), allocatable :: next !! The next item held in the iterator, if present. Otherwise !! an unallocated container. if (. not . this % filled ) return if ( this % location > size ( this % contents )) then allocate ( next , mold = this % contents ( 1 )) return end if allocate ( next , source = this % contents ( this % location )) this % location = this % location + 1 end function next","tags":"","loc":"proc/next.html","title":"next – FIAT"},{"text":"private pure function contents_type(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( container ),\n  pointer A container with the dynamic type of that used to hold the\n contents of the iterator. It is a pointer as pointer assignment\n is the easiest way to hold its \"value\" in an abstract variable. Description Returns a container with the dynamic type of that used to hold\n the contents of this iterator Source Code pure function contents_type ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Returns a container with the dynamic type of that used to hold ! the contents of this iterator ! class ( iterator ), intent ( in ) :: this class ( container ), pointer :: contents_type !! A container with the dynamic type of that used to hold the !! contents of the iterator. It is a pointer as pointer assignment !! is the easiest way to hold its \"value\" in an abstract variable. if (. not . this % filled ) return allocate ( contents_type , mold = this % contents ( 1 )) end function contents_type","tags":"","loc":"proc/contents_type.html","title":"contents_type – FIAT"},{"text":"private subroutine reset(this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Description Resets the position of the iterator to the start, so it is as\n though the next routine has never been\n called. Source Code subroutine reset ( this ) !* Author: Chris MacMackin !  Date: March 2016 ! ! Resets the position of the iterator to the start, so it is as ! though the [[iterator(type):next(bound)]] routine has never been ! called. ! class ( iterator ), intent ( inout ) :: this this % location = 1 end subroutine reset","tags":"","loc":"proc/reset.html","title":"reset – FIAT"},{"text":"public interface iterator Calls interface~~iterator~~CallsGraph interface~iterator iterator proc~constructor constructor interface~iterator->proc~constructor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function constructor (contents) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in), dimension(:) :: contents Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last.","tags":"","loc":"interface/iterator.html","title":"iterator – FIAT"},{"text":"private elemental function has_next(this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Returns whether or not this node points at another one, forming\n a chain. Source Code elemental logical function has_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not this node points at another one, forming ! a chain. ! class ( linked_node ), intent ( in ) :: this has_next = associated ( this % next ) end function has_next","tags":"","loc":"proc/has_next~2.html","title":"has_next – FIAT"},{"text":"private function get_next(this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. Source Code function get_next ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns a pointer to the node which this ones points to, i.e. the ! next node in the chain. If this node does not point at another ! one, then a null pointer is returned. ! class ( linked_node ), intent ( in ) :: this class ( linked_node ), pointer :: get_next if ( this % has_next ()) then get_next => this % next else get_next => null () end if end function get_next","tags":"","loc":"proc/get_next.html","title":"get_next – FIAT"},{"text":"private subroutine set_next(this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code subroutine set_next ( this , new_next , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Sets the node which this one points to (i.e. sets the next node in ! the chain). If this node already points to another one, the ! pointer will, by default, be nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this class ( linked_node ), pointer , intent ( in ) :: new_next !! The node which will now be next in the chain. logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. call this % unset_next ( deallocate_old ) this % next => new_next end subroutine set_next","tags":"","loc":"proc/set_next.html","title":"set_next – FIAT"},{"text":"private subroutine unset_next(this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. Source Code subroutine unset_next ( this , deallocate_old ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Unsets the pointer to the next node in the chain, severing it. ! By default, the pointer is only nullified. This may result in a ! memory leak. Optionally, by setting `deallocate_old=.true.`, the ! next node (and all nodes it points to) can be deallocated. This ! may result in a segfault if another part of the program tries to ! access the former next node. ! class ( linked_node ), intent ( inout ) :: this logical , optional , intent ( in ) :: deallocate_old !! Whether to deallocate (rather than just nullify) any existing !! subsequent nodes in the chain. Defaults to `.false.`. if (. not . this % has_next ()) return if ( present ( deallocate_old )) then if ( deallocate_old ) then call this % next % unset_next (. true .) deallocate ( this % next ) return end if end if nullify ( this % next ) end subroutine unset_next","tags":"","loc":"proc/unset_next.html","title":"unset_next – FIAT"},{"text":"private elemental function has_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Returns whether or not a values has been assigned to the node. Source Code elemental logical function has_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns whether or not a values has been assigned to the node. ! class ( node ), intent ( in ) :: this has_contents = allocated ( this % contents ) end function has_contents","tags":"","loc":"proc/has_contents.html","title":"has_contents – FIAT"},{"text":"private pure function get_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. Source Code pure function get_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! An accessor returning a [[container]] object storing the value ! placed in the node. If the contents have not been set then an ! unallocated container is returned. ! class ( node ), intent ( in ) :: this class ( container ), allocatable :: get_contents !! The stored in the node. if ( this % has_contents ()) allocate ( get_contents , source = this % contents ) end function get_contents","tags":"","loc":"proc/get_contents.html","title":"get_contents – FIAT"},{"text":"private subroutine set_contents(this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. Source Code subroutine set_contents ( this , contents ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Places a new value into storage within the node. This value must ! already be heald within an allocatable [[container]]. The actual ! argument will be deallocated after the subroutine call, as its ! allocation is moved to the contents of the node. ! class ( node ), intent ( inout ) :: this class ( container ), intent ( inout ), allocatable :: contents !* The new value to be stored in this node. The actual argument ! will be deallocated during the process of assigning it to the ! node. call this % unset_contents () call move_alloc ( contents , this % contents ) end subroutine set_contents","tags":"","loc":"proc/set_contents.html","title":"set_contents – FIAT"},{"text":"private subroutine unset_contents(this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Deallocates the value stored within the  node. Source Code subroutine unset_contents ( this ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Deallocates the value stored within the  node. ! class ( node ), intent ( inout ) :: this if ( this % has_contents ()) deallocate ( this % contents ) end subroutine unset_contents","tags":"","loc":"proc/unset_contents.html","title":"unset_contents – FIAT"},{"text":"private subroutine array_extend(this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items The items to be added to this data structure Description Adds the elements of an array to this object. Bug gfortran does not yet support dimension(*) for unlimited \n polymorphic variables, so I have had to switch to using dimension(:) when compiling with it. This means that only\n 1D arrays are accepted with gfortran . Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine array_extend ( this , items ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Adds the elements of an array to this object. ! @Bug `gfortran` does not yet support dimension(*) for unlimited ! polymorphic variables, so I have had to switch to using ! `dimension(:)` when compiling with it. This means that only ! 1D arrays are accepted with `gfortran`. ! class ( ordered ), intent ( inout ) :: this #ifdef __GFORTRAN__ class ( * ), dimension (:), intent ( in ) :: items #else class ( * ), dimension ( * ), intent ( in ) :: items #endif !! The items to be added to this data structure integer :: i do i = 1 , size ( items ) call this % push ( items ( i )) end do end subroutine array_extend","tags":"","loc":"proc/array_extend.html","title":"array_extend – FIAT"},{"text":"private subroutine iterator_extend(this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterable ), intent(inout) :: items The iterable whose contents are to be added to this data\n structure. Description Adds the contents of an iterable object to this data structure. Variables Type Visibility Attributes Name Initial type( iterator ), public :: iter_items Source Code subroutine iterator_extend ( this , items ) !* Author: Chris MacMackin !  Date: February 2016 ! ! Adds the contents of an [[iterable]] object to this data structure. ! class ( ordered ), intent ( inout ) :: this class ( iterable ), intent ( inout ) :: items !! The iterable whose contents are to be added to this data !! structure. type ( iterator ) :: iter_items iter_items = items % iter () do while ( iter_items % has_next ()) call this % push ( iter_items % next ()) end do end subroutine iterator_extend","tags":"","loc":"proc/iterator_extend.html","title":"iterator_extend – FIAT"},{"text":"private pure function queue_is_fifo() Arguments None Return Value logical Description Returns .true. , indicating that queues are a \"first in first \n out\" data structure. Source Code pure logical function queue_is_fifo () !* Author: Chris MacMackin !  Date: February 2016 ! ! Returns `.true.`, indicating that queues are a \"first in first ! out\" data structure. ! queue_is_fifo = . true . end function queue_is_fifo","tags":"","loc":"proc/queue_is_fifo.html","title":"queue_is_fifo – FIAT"},{"text":"Uses: iso_fortran_env module~~abstract_container_mod~~UsesGraph module~abstract_container_mod abstract_container_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract container derived type which can be used \n as a sort of unlimited polymorphic entity whose contents are\n retrievable with type-guards. Different subclasses are created\n in order to hold different data-types. See container for \n instructions on creating concrete subclasses. See container_mod for subclasses containing the built-in data-types. Used By module~~abstract_container_mod~~UsedByGraph module~abstract_container_mod abstract_container_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~container_mod container_mod module~abstract_container_mod->module~container_mod module~array_list_mod array_list_mod module~abstract_container_mod->module~array_list_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~map_mod map_mod module~abstract_container_mod->module~map_mod module~dictionary_mod dictionary_mod module~abstract_container_mod->module~dictionary_mod module~node_mod node_mod module~abstract_container_mod->module~node_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~dynamic_set_mod dynamic_set_mod module~abstract_container_mod->module~dynamic_set_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~data_set_mod data_set_mod module~abstract_container_mod->module~data_set_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~iterable_mod module~iterator_mod->module~ordered_mod module~array_list_mod->module~dictionary_mod module~array_list_mod->module~data_set_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~dynamic_set_mod module~countable_mod countable_mod module~iterable_mod->module~countable_mod module~map_mod->module~multimap_mod module~dictionary_mod->module~map_mod module~dictionary_mod->module~multimap_mod module~linked_node_mod linked_node_mod module~node_mod->module~linked_node_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~deque_mod->module~list_mod module~data_set_mod->module~dictionary_mod module~data_set_mod->module~dynamic_set_mod module~countable_mod->module~ordered_mod module~countable_mod->module~data_set_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod module~queue_mod->module~deque_mod var panmoduleabstract_container_modUsedByGraph = svgPanZoom('#moduleabstract_container_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface public subroutine action_sub (item) Arguments Type Intent Optional Attributes Name class( container ), intent(inout) :: item A container object which is will be modified in some way Description An abstract interface for a procedure which will act on each\n  item in a list. abstract interface private function guard (this, lhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this class(*), intent(inout) :: lhs The variable which the container contents are to be \n transferred to. Return Value logical abstract interface public pure function test_func (item) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item The item which is being evaluated Return Value logical Whether the item passes the test or not Description An abstract interface for a function which tests a container object in some way abstract interface public pure function addition_func (item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 One of the items in the addition class( container ), intent(in) :: item2 The other item in the addition Return Value class( container ),\n  allocatable The sum, item1 + item2 Description Performs an addition operation on two container objects,\n  returning the result in a container. abstract interface public pure function subtraction_func (item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 The item which the other is subtracted from class( container ), intent(in) :: item2 The item subtracted from the other Return Value real A real number, the absolute value of which represents the\n magnitude of the difference between item1 and item2 . Description An abstract interface for a procedure finding the difference\n between two items, item1 - item2 . Note that a procedure may\n satisfy both this abstract interface and comparison_func . abstract interface public pure function comparison_func (item1, item2) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: item1 The first item in the comparison class( container ), intent(in) :: item2 The second item in the comparison Return Value real negative if item1 < item2 , 0 if item1 == item2 , positive \n if item1 > item2 Description An abstract interface for a procedure comparing two container objects. Note that a procedure may satisfy both\n this abstract interface and subtraction_func . Derived Types type, public, abstract :: container Components Type Visibility Attributes Name Initial integer(kind=i1), private, dimension(:), allocatable :: storage Variable in which to place data contents logical, private :: filled = .false. .true. if container is set, .false. otherwise Type-Bound Procedures procedure(guard), private, deferred :: typeguard Performs the actual transfer of the container's contents to \n another variable. procedure, public :: contents Retrieves the contents of the container, in the form of an\n integer array. procedure, public :: is_filled Returns whether contents have been assigned to the container procedure, public :: set Sets the contents of the container. procedure, private, pass(rhs) :: assign_container Assigns container contents to another variable. procedure, private :: is_equal Check whether two containers have the same contents. generic, public :: assignment(=) => assign_container generic, public :: operator(==) => is_equal Description An abstract derived type which contains data. This type can be\n used for a sort of unlimited polymorphism. It is extended to\n create different classes capable of holding particular \n data-types. Extensions must implement the procedure typeguard in order to provide the ability to\n transfer data out of the container and into a variable. Assuming\n that you are creating a concrete class called example_container , this should be implemented as follows: Functions private pure function contents (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value integer(kind=i1),\n  dimension(:),allocatable Description Author Chris MacMackin Date December 2015 Returns the contents, encoded as a character array, of the \n container. private elemental function is_filled (this) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date March 2016 Returns .true. if a value has been assigned to the container, .false. otherwise. private elemental function is_equal (lhs, rhs) Arguments Type Intent Optional Attributes Name class( container ), intent(in) :: lhs class( container ), intent(in) :: rhs Return Value logical Description Author Chris MacMackin Date December 2015 Checks whether two containers are of the same type and are\n storing the same contents. Subroutines private subroutine assign_container (lhs, rhs) Arguments Type Intent Optional Attributes Name class(*), intent(inout) :: lhs The variable which the container contents will be assigned to. class( container ), intent(in) :: rhs The container variable. Description Author Chris MacMackin Date December 2015 Transfers the contents of the container to another variable.\n If the other variable is another container of the same type\n then the contents will be transferred. If the other variable is\n the same type as the contents of the container (as determined\n by the typeguard routine provided for that \n concrete type extension) then it will be given the value held by\n the container. Otherwise, an error message will be printed and \n the program stopped. If compiled with gfortran then a backtrace\n will also be printed. In the event that the container was never\n set to a value, then this also constitutes an error. private subroutine set (this, content) Arguments Type Intent Optional Attributes Name class( container ), intent(out) :: this class(*), intent(in) :: content The value to be placed in the container Description Author Chris MacMackin Date December 2015 Sets the contents of the storage array to value passed. The type\n of the variable provided must be the same as the container\n variable is designed to accept (as determined by the\n concrete type implementation of the typeguard method in the extension) or be of the same type of container.\n Otherwise an error message will be printed and the program will \n exit. If gfortran was used to compile then a backtrace will\n also be printed.","tags":"","loc":"module/abstract_container_mod.html","title":"abstract_container_mod – FIAT"},{"text":"Uses: list_mod abstract_container_mod iterator_mod ordered_mod module~~array_list_mod~~UsesGraph module~array_list_mod array_list_mod module~list_mod list_mod module~list_mod->module~array_list_mod module~ordered_mod ordered_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~array_list_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmodulearray_list_modUsesGraph = svgPanZoom('#modulearray_list_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides a concrete implementation of the list abstract data\n type. This implementation, the array_list , stores values in an\n array and thus fast to read from. Used By module~~array_list_mod~~UsedByGraph module~array_list_mod array_list_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( list ) :: array_list Components Type Visibility Attributes Name Initial class( container ), private, allocatable, dimension(:) :: contents integer, private :: length Type-Bound Procedures procedure, public :: iter => array_list_iter procedure, public :: contents_type => array_list_contents_type procedure, public :: size => array_list_size procedure, public :: push => array_list_push procedure, public :: pop => array_list_pop procedure, public :: peek => array_list_peek procedure, private :: concat => array_list_concat procedure, public :: clear => array_list_clear procedure, public :: pushleft => array_list_push procedure, public :: pushright => array_list_append procedure, public :: popleft => array_list_popleft procedure, public :: popright => array_list_pop procedure, public :: peekleft => array_list_peekleft procedure, public :: peekright => array_list_peek procedure, public :: append => array_list_append procedure, public :: get => array_list_get procedure, private :: set_single => array_list_set_single procedure, private :: set_multiple => array_list_set_multiple procedure, public :: get_index => array_list_get_index procedure, public :: get_last_index => array_list_get_last_index procedure, public :: get_indices => array_list_get_indices procedure, public :: slice => array_list_slice procedure, public :: foreach => array_list_foreach procedure, public :: insert => array_list_insert procedure, public :: remove => array_list_remove procedure, public :: remove_last => array_list_remove_last procedure, public :: remove_all => array_list_remove_all procedure, private :: delete_single => array_list_delete_single procedure, private :: delete_multiple => array_list_delete_multiple procedure, private :: delete_slice => array_list_delete_slice procedure, public :: has => array_list_has procedure, public :: sort => array_list_sort procedure, public :: min => array_list_min procedure, public :: max => array_list_max procedure, public :: nearest => array_list_nearest procedure, public :: sum => array_list_sum procedure, public :: filter => array_list_filter procedure, public :: to_array => array_list_to_array Description A concrete implementation of the list abstract data type.\n This implementation stores list contents in an array. It is fast\n to read from, but it is slow to insert elements into the middle\n of the list or to add new items to the end (if doing so requires\n the storage array to be expanded). Functions private pure function array_list_iter (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Returns an iterator containing the contents of this list\n as they were at the time this method was called. private pure function array_list_contents_type (this) result(cont) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable Description Author Chris MacMackin Date March 2016 Returns a container with the dynamic type of the contents of this\n list. private pure function array_list_size (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value integer Description Author Chris MacMackin Date March 2016 Returns the number of items in the list private function array_list_pop (this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The value from the end of the list Description Author Chris MacMackin Date March 2016 Removes the item at the end of the list and returns it. private pure function array_list_peek (this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The element at the end of the list Description Author Chris MacMackin Date March 2016 Returns the item at the end of the list, without removing it. private pure function array_list_concat (lhs, rhs) result(concat) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: lhs The list class( ordered ), intent(in) :: rhs The object being concatenated to the list Return Value class( ordered ),\n  allocatable The concatenated object. Will have dynamic type array_list . Description Author Chris MacMackin Date March 2016 Join this list with an ordered object, returning the result. The \n contents of the returned object are ordered such that applying pop until it is empty would return items in the same order as \n calling pop until the list is empty and then until the second \n object is empty. private function array_list_popleft (this) result(pop) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Return Value class( container ),\n  allocatable The item just removed from the start of the list Description Author Chris MacMackin Date March 2016 Removes the item at the start of the list and returns it. private pure function array_list_peekleft (this) result(peek) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  allocatable The item at the start of the list Description Author Chris MacMackin Date March 2016 Returns the item at the start of the list. private pure function array_list_get (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element . Unallocated if no such element\n is present. Description Author Chris MacMackin Date March 2016 Returns the item at the specified location in the list. Returns\n an unallocated container if that location has not been set. private pure function array_list_get_index (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list Description Author Chris MacMackin Date March 2016 Returns the index of the first occurrence of the item in the list.\n If there are no occurrences, then returns -1. private pure function array_list_get_last_index (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list. -1 if item not present Description Author Chris MacMackin Date March 2016 Returns the index of the last occurrence of the item in the list.\n If there are no occurrences, then returns -1. private pure function array_list_get_indices (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list. Unallocated\n if item not present. Description Author Chris MacMackin Date March 2016 Returns an array containing the indices of all occurrences of the\n item in the list. If there are no occurrences, then returns an\n unallocated array. private function array_list_slice (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable An array_list containing the elements within the slice. Description Author Chris MacMackin Date March 2016 Returns an array_list instance containing all items in this\n list within the specified slice, inclusive. Crashes if one of\n the indices is outside of the list's bounds. private elemental function array_list_has (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise Description Author Chris MacMackin Date March 2016 Indicates whether there are any copies of the specified item\n present in the list. private pure function array_list_min (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function Description Author Chris MacMackin Date March 2016 Returns the smallest item contained in the list, as determined\n using the provided comparison function. private pure function array_list_max (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function Description Author Chris MacMackin Date March 2016 Returns the largest item contained in the list, as determined\n using the provided comparison function. private pure function array_list_nearest (this, item, subtraction) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value Description Author Chris MacMackin Date March 2016 Returns the value contained in the list for which the subtraction\n function returns the smallest absolute real number when comparing\n with the specified item . private pure function array_list_sum (this, addition) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list Description Author Chris MacMackin Date March 2016 Returns a container representing the sum of all items \n contained in the list. This sum is calculated by repeatedly\n applying the addition procedure to the list's contents. private pure function array_list_filter (this, test) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true. Description Author Chris MacMackin Date March 2016 Returns a new list containing only those items held in this list\n which pass the provided test. private pure function array_list_to_array (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list Description Author Chris MacMackin Date March 2016 Returns copies of all items held in this list, stored within an\n array of container objects. Subroutines private pure subroutine array_list_push (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item The value to place at the start of the list. Description Author Chris MacMackin Date March 2016 Adds an item to the beginning of the list. private pure subroutine array_list_clear (this) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this Description Author Chris MacMackin Date March 2016 Removes all items from this list, but does not change its container type. private pure subroutine array_list_append (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list Description Author Chris MacMackin Date March 2016 Adds the provided item to the end of the list. private subroutine array_list_set_single (this, element, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element Description Author Chris MacMackin Date March 2016 Places the value of the provided element in the specified location\n in the array. Crashes if this element is not already defined. private subroutine array_list_set_multiple (this, elements, items) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . Description Author Chris MacMackin Date March 2016 Places the values of the provided array of items in the locations\n specified by the corresponding indices in the in the array of\n elements. private subroutine array_list_foreach (this, action) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list Description Author Chris MacMackin Date March 2016 Performs the specified action on each item in the list, in place. private subroutine array_list_insert (this, position, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list Description Author Chris MacMackin Date March 2016 Places the provided item into the list at the position specified,\n moving all succeeding items forward by one. The position must be\n one which is already filled or the length of the list plus one. private subroutine array_list_remove (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list Description Author Chris MacMackin Date March 2016 Remove the first occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. private subroutine array_list_remove_last (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list Description Author Chris MacMackin Date March 2016 Remove the last occurrence of the specified item from the list,\n moving all succeeding items back by one position. No action is\n taken if the item is not present. private subroutine array_list_remove_all (this, item) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list Description Author Chris MacMackin Date March 2016 Remove all occurrences of the specified item from the list,\n moving all succeeding items back in position. No action is taken\n if the item is not present. private subroutine array_list_delete_single (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list Description Author Chris MacMackin Date March 2016 Removes the element at the specified position in the list, moving\n all succeeding items back by one position. Crashes if the element\n has not been set. private subroutine array_list_delete_multiple (this, element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list Description Author Chris MacMackin Date March 2016 Removes the elements at the positions specified by the indices in\n the array elements from the list. The elements removed are those\n at the specified location just before the call was made. Once all\n removals have been performed, the remaining elements well be moved\n backwards in position as necessary. Crashes if an element has not\n been set. private subroutine array_list_delete_slice (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted Description Author Chris MacMackin Date March 2016 Removes the element within the specified slice of the list, moving\n all succeeding items back by the number of items deleted. The \n slice contains the element at the start index to the end index,\n inclusive. Crashes if part of the slice has not been set. private subroutine array_list_sort (this, comparison) Arguments Type Intent Optional Attributes Name class( array_list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Description Author Chris MacMackin Date March 2016 Sorts the list, in place, so that all items are in ascending order\n according the the provided comparison function.","tags":"","loc":"module/array_list_mod.html","title":"array_list_mod – FIAT"},{"text":"Uses: linked_node_mod module~~bidir_node_mod~~UsesGraph module~bidir_node_mod bidir_node_mod module~linked_node_mod linked_node_mod module~linked_node_mod->module~bidir_node_mod module~node_mod node_mod module~node_mod->module~linked_node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Implements a node which contains a pointer to two other (the next \n and previous) nodes, allowing a chain to be formed. This can be used\n to, for example, build a doubly-linked lists. It is not anticipated that the bidir_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. Derived Types type, public, extends( linked_node ) :: bidir_node Components Type Visibility Attributes Name Initial class( bidir_node ), private, pointer :: prev => null() Type-Bound Procedures procedure, public :: has_prev procedure, public :: get_prev procedure, public :: set_prev procedure, public :: unset_prev Description A node which, in addition to holding a value, points at two other\n (the previous and next) bidir_node objects or objects of a\n descendent type. This type can be built up into a chain, allowing\n a doubly-linked list to be formed. Functions private elemental function has_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points to a previous one, forming\n a chain in the backwards direction. private function get_prev (this) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(in) :: this Return Value class( bidir_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the previous node in the chain. If this node\n does not point at a previous one one, then a null pointer is\n returned. Subroutines private subroutine set_prev (this, new_prev, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this class( bidir_node ), intent(in), pointer :: new_prev The node which will now be previous in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n previous nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the pointer to the previous node in the chain. If this node\n already points to a previous one, the pointer will, by default, be\n nullified. This may result in a memory leak. Optionally, by\n setting deallocate_old=.true. , the previous node (and all nodes\n it points to) can be deallocated. This may result in a segfault if\n another part of the program tries to access the former previous\n node. The new previous node will not automatically be set to have\n this one as the next, with the same rules applied to deallocation. private subroutine unset_prev (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( bidir_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n p nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the previous node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n previous node (and all previous nodes it points to) can be\n deallocated. This may result in a segfault if another part of the\n program tries to access the former previous node.","tags":"","loc":"module/bidir_node_mod.html","title":"bidir_node_mod – FIAT"},{"text":"Uses: abstract_container_mod iso_fortran_env module~~container_mod~~UsesGraph module~container_mod container_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~container_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~container_mod iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides implementations of the container abstract\n derived type for all of the intrinsic variable types. Derived Types type, public, extends( container ) :: int_container Type-Bound Procedures procedure, private :: typeguard => int_guard Description A container for holding the defualt integer type. type, public, extends( container ) :: int1_container Type-Bound Procedures procedure, private :: typeguard => int1_guard Description A container for holding the 1 byte integer type. type, public, extends( container ) :: int2_container Type-Bound Procedures procedure, private :: typeguard => int2_guard Description A container for holding the 2 byte integer type. type, public, extends( container ) :: int4_container Type-Bound Procedures procedure, private :: typeguard => int4_guard Description A container for holding the 4 byte integer type. type, public, extends( container ) :: int8_container Type-Bound Procedures procedure, private :: typeguard => int8_guard Description A container for holding the 8 byte integer type. type, public, extends( container ) :: real_container Type-Bound Procedures procedure, private :: typeguard => real_guard Description A container for holding the defualt real type. type, public, extends( container ) :: real4_container Type-Bound Procedures procedure, private :: typeguard => real4_guard Description A container for holding the 4 byte real type. type, public, extends( container ) :: real8_container Type-Bound Procedures procedure, private :: typeguard => real8_guard Description A container for holding the 8 byte real type. type, public, extends( container ) :: real16_container Type-Bound Procedures procedure, private :: typeguard => real16_guard Description A container for holding the 16 byte real type. type, public, extends( container ) :: complex_container Type-Bound Procedures procedure, private :: typeguard => complex_guard Description A container for holding the defualt complex type. type, public, extends( container ) :: complex4_container Type-Bound Procedures procedure, private :: typeguard => complex4_guard Description A container for holding the 4 byte complex type. type, public, extends( container ) :: complex8_container Type-Bound Procedures procedure, private :: typeguard => complex8_guard Description A container for holding the 8 byte complex type. type, public, extends( container ) :: complex16_container Type-Bound Procedures procedure, private :: typeguard => complex16_guard Description A container for holding the 16 byte complex type. type, public, extends( container ) :: logical_container Type-Bound Procedures procedure, private :: typeguard => logical_guard Description A container for holding the defualt logical type. type, public, extends( container ) :: character_container Type-Bound Procedures procedure, private :: typeguard => character_guard Description A container for holding the defualt character type. Functions private function int_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int1_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int1_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int2_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int2_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function int8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( int8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function real16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( real16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex4_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex4_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex8_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex8_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function complex16_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( complex16_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function logical_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( logical_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type. private function character_guard (this, lhs) result(ret) Arguments Type Intent Optional Attributes Name class( character_container ), intent(in) :: this class(*), intent(inout) :: lhs Return Value logical Description Author Chris MacMackin Date December 2015 Transfers the container's contents to the variable on the left\n hand side of the equals sign if it is of the correct type.","tags":"","loc":"module/container_mod.html","title":"container_mod – FIAT"},{"text":"Uses: iterable_mod module~~countable_mod~~UsesGraph module~countable_mod countable_mod module~iterable_mod iterable_mod module~iterable_mod->module~countable_mod module~iterator_mod iterator_mod module~iterator_mod->module~iterable_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~iterable_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides the countable abstract type. For a type to be\n countable, the number of individual pieces of data stored within\n must be known in advance. Used By module~~countable_mod~~UsedByGraph module~countable_mod countable_mod module~ordered_mod ordered_mod module~countable_mod->module~ordered_mod module~data_set_mod data_set_mod module~countable_mod->module~data_set_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~array_list_mod array_list_mod module~ordered_mod->module~array_list_mod module~dictionary_mod dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~deque_mod deque_mod module~queue_mod->module~deque_mod module~array_list_mod->module~data_set_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~array_list_mod->module~dictionary_mod module~list_mod list_mod module~deque_mod->module~list_mod module~list_mod->module~array_list_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~map_mod->module~multimap_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod var panmodulecountable_modUsedByGraph = svgPanZoom('#modulecountable_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure function size_func (this) Arguments Type Intent Optional Attributes Name class( countable ), intent(in) :: this Return Value integer The number of items stored in this object. Derived Types type, public, abstract, extends( iterable ) :: countable Type-Bound Procedures procedure(size_func), public, deferred :: size Return the number of items stored within this object Description An abstract data type which can be iterated, for which the number of\n pieces of items of data stored within is known.","tags":"","loc":"module/countable_mod.html","title":"countable_mod – FIAT"},{"text":"Uses: abstract_container_mod countable_mod array_list_mod module~~data_set_mod~~UsesGraph module~data_set_mod data_set_mod module~countable_mod countable_mod module~countable_mod->module~data_set_mod module~ordered_mod ordered_mod module~countable_mod->module~ordered_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~data_set_mod module~array_list_mod array_list_mod module~abstract_container_mod->module~array_list_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~ordered_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~array_list_mod->module~data_set_mod module~iterable_mod->module~countable_mod module~iterable_mod->module~ordered_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~iterable_mod module~iterator_mod->module~ordered_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod var panmoduledata_set_modUsesGraph = svgPanZoom('#moduledata_set_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for the set data structure. Such sets\n support similar operations to their mathematical counterparts.\n This class, and its descendents, have a comparable set of methods\n to those in the Python frozenset type. Used By module~~data_set_mod~~UsedByGraph module~data_set_mod data_set_mod module~dictionary_mod dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~multimap_mod multimap_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure function union_func (this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing all elements found in this one and the other abstract interface private pure function intersect_func (this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value integer abstract interface private pure function diff_func (this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in this one and not the other abstract interface private pure function pure_diff_func (this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value class( data_set ),\n  allocatable A set containing elements found in one, but not both, of this\n set or the other set abstract interface private pure function relation_func (this, other) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class( data_set ), intent(in) :: other A second set Return Value logical Whether the relationship between this and other is true abstract interface private pure function has_func (this, item) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item An item which may be contained in the set Return Value logical Whether item is present in this set abstract interface private pure function empty_func (this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value logical .true. if this set contains no items abstract interface private pure function peek_func (this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value class( container ),\n  allocatable An item contained within the set. Is unallocated if the set\n is empty. abstract interface private pure function filter_func (this, test) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( data_set ),\n  allocatable Contains those items in this set for which test returns .true. abstract interface private pure function enum_func (this) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this Return Value type( array_list ) A list containing copies of all of the items in this set abstract interface private pure function min_func (this, comparison) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the set, as determined by the comparison function abstract interface private pure function max_func (this, comparison) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the set, as determined by the comparison function abstract interface private pure function nearest_func (this, item, subtraction) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this class(*), intent(in) :: item The value which those in the set are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the set which, when passed to subtraction with item as the other argument, returns the smallest value abstract interface private pure function sum_func (this, addition) Arguments Type Intent Optional Attributes Name class( data_set ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this set Derived Types type, public, abstract, extends( countable ) :: data_set Type-Bound Procedures procedure(union_func), public, deferred :: union Returns a set containing the items held in this set and the\n passed set. generic, public :: operator(+) => union Returns the union of the two sets procedure(intersect_func), public, deferred :: intersection Returns a set containing only the items present in both this\n set and the argument procedure(diff_func), public, deferred :: difference Returns a set containing the item present in this set but not\n present in the argument generic, public :: operator(-) => difference Returns the difference between the two sets procedure(pure_diff_func), public, deferred :: symmetric_difference Returns a set containing those items present either only in \n this set or only in the argument procedure(relation_func), public, deferred :: is_disjoint True if none of the items in this set are present in the \n argument procedure(relation_func), public, deferred :: is_subset True if every element in this set is also in the argument procedure(relation_func), public, deferred :: is_proper_subset True if every element in this set is also in the argument and\n this set is not equal to the argument procedure(relation_func), public, deferred :: is_superset True if every element in the argument is also present in this\n set. procedure(relation_func), public, deferred :: is_proper_superset True if every element in the argument is also present in this\n set and the argument is not equal to this set. procedure(relation_func), public, deferred :: is_equal True if this set and the argument contain only the same items. generic, public :: operator(<=) => is_subset True if every element in this set is also in the argument generic, public :: operator(<) => is_proper_subset True if every element in this set is also in the argument and\n this set is not equal to the argument generic, public :: operator(>=) => is_superset True if every element in the argument is also present in this\n set. generic, public :: operator(>) => is_proper_superset True if every element in the argument is also present in this\n set and the argument is not equal to this set. generic, public :: operator(==) => is_equal True if this set and the argument contain only the same items. procedure(has_func), public, deferred :: has True if the argument is present in the set procedure(empty_func), public, deferred :: is_empty True if the set contains no items procedure(peek_func), public, deferred :: peek Returns an item, at random, from the set procedure(filter_func), public, deferred :: filter Returns a set containing all elements from this set for which\n the provided test procedure returns .true. procedure(enum_func), public, deferred :: enumerate Returns an [array_list] containing all of the items present\n in this set. procedure(min_func), public, deferred :: min Returns the smallest item in the set as determined using the\n provided comparison procedure procedure(max_func), public, deferred :: max Returns the largest item in the set as determined using the\n provided comparison procedure procedure(nearest_func), public, deferred :: nearest Returns the item in the set for which the provided subtraction\n procedure returns the smallest absolute value procedure(sum_func), public, deferred :: sum Returns an item representing the sum as determined by\n iteratively applying the provided addition procedure to all\n items in the set Description An abstract type for set data structures. These sets support a \n similar selection of operations as do their mathematical\n counterparts. The collection of methods for this type waas inspired\n by those available for the frozenset type in Python.","tags":"","loc":"module/data_set_mod.html","title":"data_set_mod – FIAT"},{"text":"Uses: queue_mod abstract_container_mod module~~deque_mod~~UsesGraph module~deque_mod deque_mod module~queue_mod queue_mod module~queue_mod->module~deque_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~deque_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~ordered_mod->module~queue_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmoduledeque_modUsesGraph = svgPanZoom('#moduledeque_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides a doubled ended queue abstract data type. This is a first\n in first out data structure which can be added to or taken from at\n either end. Used By module~~deque_mod~~UsedByGraph module~deque_mod deque_mod module~list_mod list_mod module~deque_mod->module~list_mod module~array_list_mod array_list_mod module~list_mod->module~array_list_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod var panmoduledeque_modUsedByGraph = svgPanZoom('#moduledeque_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure subroutine push_sub (this, item) Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this class(*), intent(in) :: item The value to be added to the list abstract interface private function pop_func (this) Arguments Type Intent Optional Attributes Name class( deque ), intent(inout) :: this Return Value class( container ),\n  allocatable The next value, which has just been removed abstract interface private pure function peek_func (this) Arguments Type Intent Optional Attributes Name class( deque ), intent(in) :: this Return Value class( container ),\n  allocatable The next value, which is not removed Derived Types type, public, abstract, extends( queue ) :: deque Type-Bound Procedures procedure(push_sub), public, deferred :: pushleft Add an item to the left end of the data structure (equivalent\n to push on a queue) procedure(push_sub), public, deferred :: pushright Add an item to the right end of the data structure procedure(pop_func), public, deferred :: popleft Remove and return the item from the left end of the data\n structure procedure(pop_func), public, deferred :: popright Remove and return the item from the right end of the data\n structure (equivalent to pop on a queue) procedure(peek_func), public, deferred :: peekleft Return, but do not remove, the item at the left end of the data\n structure procedure(peek_func), public, deferred :: peekright Return, but do not remove, the item at the left end of the data\n structure (equivalent to peek on a queue) Description An abstract data type representing the double ended queue data\n structure. Rather than just pushing items to one end (the \"left \n end\") and popping them from the other (the \"right end\"), items can\n be pushed or popped to/from either the right or the left.","tags":"","loc":"module/deque_mod.html","title":"deque_mod – FIAT"},{"text":"Uses: abstract_container_mod data_set_mod array_list_mod module~~dictionary_mod~~UsesGraph module~dictionary_mod dictionary_mod module~array_list_mod array_list_mod module~array_list_mod->module~dictionary_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~dictionary_mod module~abstract_container_mod->module~array_list_mod module~abstract_container_mod->module~data_set_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~data_set_mod->module~dictionary_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod module~countable_mod countable_mod module~countable_mod->module~data_set_mod module~countable_mod->module~ordered_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmoduledictionary_modUsesGraph = svgPanZoom('#moduledictionary_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for mapping data structures. These are\n data structures which consist of key-value pairs. Used By module~~dictionary_mod~~UsedByGraph module~dictionary_mod dictionary_mod module~multimap_mod multimap_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~map_mod->module~multimap_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure function keys_func (this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the keys in this dictionary abstract interface private pure function values_func (this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value type( array_list ) A list containing all of the values in this dictionary,\n stored in the same order as their corresponding key would\n be were keys called abstract interface private function set_func (this, key, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: this class(*), intent(in) :: key The key whose value is to be set class(*), intent(in) :: val The value to be assigned to the specified key Return Value real abstract interface private pure function type_func (this) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used to store this \n dictionary's keys or values. Derived Types type, public, abstract, extends( data_set ) :: dictionary Type-Bound Procedures procedure(keys_func), public, deferred :: keys Returns a list of the keys in this dictionary procedure(values_func), public, deferred :: values Returns a list of the values stored in this dictionary, in the\n same order as the corresponding keys are returned when keys is called procedure(set_func), public, deferred :: set Sets the given key to the give value procedure(type_func), public, deferred :: key_type Returns a container of the dynamics type used to store keys procedure(type_func), public, deferred :: value_type Returns a container of dynamics the type used to store \n values Description An abstract type for mapping data structures. These are data \n structures which consist of key-value pairs. Examples of such\n structures are dictionaries in Python or a hash variable in Perl.","tags":"","loc":"module/dictionary_mod.html","title":"dictionary_mod – FIAT"},{"text":"Uses: abstract_container_mod iterable_mod data_set_mod module~~dynamic_set_mod~~UsesGraph module~dynamic_set_mod dynamic_set_mod module~iterable_mod iterable_mod module~iterable_mod->module~dynamic_set_mod module~countable_mod countable_mod module~iterable_mod->module~countable_mod module~ordered_mod ordered_mod module~iterable_mod->module~ordered_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~dynamic_set_mod module~abstract_container_mod->module~iterable_mod module~data_set_mod data_set_mod module~abstract_container_mod->module~data_set_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~array_list_mod array_list_mod module~abstract_container_mod->module~array_list_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~ordered_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~data_set_mod->module~dynamic_set_mod module~iterator_mod->module~iterable_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod module~countable_mod->module~data_set_mod module~countable_mod->module~ordered_mod module~array_list_mod->module~data_set_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod var panmoduledynamic_set_modUsesGraph = svgPanZoom('#moduledynamic_set_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for a dynamic set data structures. This\n data structure is similar to a normal data_set structure, but\n new items can be added to the set. It is similar to the set type in\n Python. Used By module~~dynamic_set_mod~~UsedByGraph module~dynamic_set_mod dynamic_set_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface public pure subroutine single_sub (this, item) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in) :: item An item to add or remove from the set abstract interface public pure subroutine multiple_sub (this, items) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class(*), intent(in), dimension(:) :: items An array containing items to add or remove from the set abstract interface public pure subroutine iter_sub (this, items) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this class( iterable ), intent(in) :: items An iterable containing items to add or remove from the set abstract interface public pure subroutine clear_sub (this) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this abstract interface public function pop_func (this) Arguments Type Intent Optional Attributes Name class( dynamic_set ), intent(inout) :: this Return Value class( container ),\n  allocatable A random item which has been removed from the set Derived Types type, public, abstract, extends( data_set ) :: dynamic_set Type-Bound Procedures procedure(single_sub), private, deferred :: add_single Places the item in the set, if not already present procedure(multiple_sub), private, deferred :: add_multiple Places each item in the array into the set, if not already \n present generic, public :: add => add_single, add_multiple procedure(iter_sub), public, deferred :: add_iter Places each item in the iterable into the set, if not already\n present. procedure(single_sub), private, deferred :: remove_single Removes the item from the set, if present procedure(multiple_sub), private, deferred :: remove_multiple Removes each item in the array from the set, if present generic, public :: remove => remove_single, remove_multiple procedure(iter_sub), public, deferred :: remove_iter Removes each item in the iterable from the set, if present procedure(pop_func), public, deferred :: pop Removes a random item from the set and returns it procedure(clear_sub), public, deferred :: clear Removes all items from the set Description An abstract data type for dynamic sets. These are much like\n mathematical sets, but differ from the parent data_set type\n in that items can be added to or removed from the set. To\n accomplish this, various additional methods are available. This\n data type is similar to the set type in\n Python.","tags":"","loc":"module/dynamic_set_mod.html","title":"dynamic_set_mod – FIAT"},{"text":"Uses: abstract_container_mod iterator_mod module~~iterable_mod~~UsesGraph module~iterable_mod iterable_mod module~iterator_mod iterator_mod module~iterator_mod->module~iterable_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~iterable_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides the iterable abstract type. All of FIATs more complex\n public data structures are descendants of this type. Used By module~~iterable_mod~~UsedByGraph module~iterable_mod iterable_mod module~countable_mod countable_mod module~iterable_mod->module~countable_mod module~ordered_mod ordered_mod module~iterable_mod->module~ordered_mod module~dynamic_set_mod dynamic_set_mod module~iterable_mod->module~dynamic_set_mod module~countable_mod->module~ordered_mod module~data_set_mod data_set_mod module~countable_mod->module~data_set_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~array_list_mod array_list_mod module~ordered_mod->module~array_list_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod dictionary_mod module~data_set_mod->module~dictionary_mod module~multimap_mod multimap_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~map_mod->module~multimap_mod module~deque_mod deque_mod module~queue_mod->module~deque_mod module~array_list_mod->module~data_set_mod module~array_list_mod->module~dictionary_mod module~array_list_mod->module~multimap_mod module~list_mod list_mod module~deque_mod->module~list_mod module~list_mod->module~array_list_mod var panmoduleiterable_modUsedByGraph = svgPanZoom('#moduleiterable_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure function iterator_return (this) Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value type( iterator ) An iterator with the contents of this object abstract interface private pure function container_return (this) Arguments Type Intent Optional Attributes Name class( iterable ), intent(in) :: this Return Value class( container ),\n  allocatable A container of the dynamic type used in this object Derived Types type, public, abstract :: iterable Type-Bound Procedures procedure(iterator_return), public, deferred :: iter Return an iterator object with the contents of the iterable procedure(container_return), public, deferred :: contents_type Return a container object with the dynamic type of that\n used in this iterable Description An abstract type which can return and iterator object\n representing its contents. All of the more complex public data \n structures in FIAT are descendants of this one.","tags":"","loc":"module/iterable_mod.html","title":"iterable_mod – FIAT"},{"text":"Uses: abstract_container_mod module~~iterator_mod~~UsesGraph module~iterator_mod iterator_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~iterator_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides the iterator data type which can be used to access a\n collection of data. Used By module~~iterator_mod~~UsedByGraph module~iterator_mod iterator_mod module~iterable_mod iterable_mod module~iterator_mod->module~iterable_mod module~ordered_mod ordered_mod module~iterator_mod->module~ordered_mod module~array_list_mod array_list_mod module~iterator_mod->module~array_list_mod module~iterable_mod->module~ordered_mod module~countable_mod countable_mod module~iterable_mod->module~countable_mod module~dynamic_set_mod dynamic_set_mod module~iterable_mod->module~dynamic_set_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~countable_mod->module~ordered_mod module~countable_mod->module~data_set_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~data_set_mod->module~dynamic_set_mod module~data_set_mod->module~dictionary_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~map_mod->module~multimap_mod module~deque_mod deque_mod module~queue_mod->module~deque_mod module~list_mod list_mod module~deque_mod->module~list_mod module~list_mod->module~array_list_mod var panmoduleiterator_modUsedByGraph = svgPanZoom('#moduleiterator_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface iterator private pure function constructor (contents) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in), dimension(:) :: contents Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last. Derived Types type, public :: iterator Components Type Visibility Attributes Name Initial class( container ), private, allocatable, dimension(:) :: contents integer, private :: location = 1 logical, private :: filled = .false. Constructor private pure function constructor (contents) Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last. Type-Bound Procedures procedure, public :: has_next procedure, public :: next procedure, public :: reset procedure, public :: contents_type Description A data type which provides a collection of data to the user. Objects\n of this type are returned using the iter method of\n FIAT's other data types. The contents of the iterator are set to be\n the same as the iterable at the time when the iter method was \n called. If new items are later added to the iterable object, this\n will not be reflected in the iterator object. Functions private pure function constructor (contents) result(new) Arguments Type Intent Optional Attributes Name class( container ), intent(in), dimension(:) :: contents Return Value type( iterator ) Description Author Chris MacMackin Date March 2016 Creates an iterator from an array of containers containing\n the data to be returned upon iteration. The data is returned\n starting with the first element of the array and ending with\n the last. private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value logical Whether there are additional items to iterate through Description Author Chris MacMackin Date March 2016 Returns .true. if there are any remaining objects through which\n to iterate, and .false. otherwise. private function next (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item held in the iterator, if present. Otherwise\n an unallocated container. Description Author Chris MacMackin Date March 2016 Returns the next item stored in the iterator. If there are no\n more items present then an empty container is returned. If\n there are no contents stored in this iterator then it returns\n an unallocated container . private pure function contents_type (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(in) :: this Return Value class( container ),\n  pointer A container with the dynamic type of that used to hold the\n contents of the iterator. It is a pointer as pointer assignment\n is the easiest way to hold its \"value\" in an abstract variable. Description Author Chris MacMackin Date March 2016 Returns a container with the dynamic type of that used to hold\n the contents of this iterator Subroutines private subroutine reset (this) Arguments Type Intent Optional Attributes Name class( iterator ), intent(inout) :: this Description Author Chris MacMackin Date March 2016 Resets the position of the iterator to the start, so it is as\n though the next routine has never been\n called.","tags":"","loc":"module/iterator_mod.html","title":"iterator_mod – FIAT"},{"text":"Uses: node_mod module~~linked_node_mod~~UsesGraph module~linked_node_mod linked_node_mod module~node_mod node_mod module~node_mod->module~linked_node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Implements a node which contains a pointer to another (the next) \n node, allowing a chain to be formed. This can be used to, for\n example, build linked lists. It is not anticipated that the linked_node type, or any types \n extending it, will be handled directly by end users of FIAT; they \n are meant for internal use within this package. Used By module~~linked_node_mod~~UsedByGraph module~linked_node_mod linked_node_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( node ) :: linked_node Components Type Visibility Attributes Name Initial class( linked_node ), private, pointer :: next => null() The next node in the chain. Type-Bound Procedures procedure, public :: has_next Checks whether this node points to another one procedure, public :: get_next Returns the next node in the chain if it exists. procedure, public :: set_next Sets the next node in the chain. procedure, public :: unset_next Sets this node not to point at any others, severing the chain. Description A node which, in addition to holding a value, points at another\n (the next) linked_node or descendent type. This type can be built\n up into a chain, allowing a linked list to be formed. Functions private elemental function has_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not this node points at another one, forming\n a chain. private function get_next (this) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(in) :: this Return Value class( linked_node ),\n  pointer Description Author Chris MacMackin Date February 2016 Returns a pointer to the node which this ones points to, i.e. the\n next node in the chain. If this node does not point at another \n one, then a null pointer is returned. Subroutines private subroutine set_next (this, new_next, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this class( linked_node ), intent(in), pointer :: new_next The node which will now be next in the chain. logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Sets the node which this one points to (i.e. sets the next node in\n the chain). If this node already points to another one, the \n pointer will, by default, be nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node. private subroutine unset_next (this, deallocate_old) Arguments Type Intent Optional Attributes Name class( linked_node ), intent(inout) :: this logical, intent(in), optional :: deallocate_old Whether to deallocate (rather than just nullify) any existing\n subsequent nodes in the chain. Defaults to .false. . Description Author Chris MacMackin Date February 2016 Unsets the pointer to the next node in the chain, severing it.\n By default, the pointer is only nullified. This may result in a\n memory leak. Optionally, by setting deallocate_old=.true. , the\n next node (and all nodes it points to) can be deallocated. This\n may result in a segfault if another part of the program tries to\n access the former next node.","tags":"","loc":"module/linked_node_mod.html","title":"linked_node_mod – FIAT"},{"text":"Uses: deque_mod abstract_container_mod module~~list_mod~~UsesGraph module~list_mod list_mod module~deque_mod deque_mod module~deque_mod->module~list_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~deque_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~queue_mod queue_mod module~queue_mod->module~deque_mod module~ordered_mod->module~queue_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmodulelist_modUsesGraph = svgPanZoom('#modulelist_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract data type representing a list. This interface\n provides a derived type with many of the same abilities as lists in\n higher-level languages such as Python. Used By module~~list_mod~~UsedByGraph module~list_mod list_mod module~array_list_mod array_list_mod module~list_mod->module~array_list_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod var panmodulelist_modUsedByGraph = svgPanZoom('#modulelist_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine append_sub (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item Item to be appended to list abstract interface private subroutine set_single_sub (this, element, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The index (starting from 1) of the element whose value is to be set. class(*), intent(in) :: item The value to store in the specified element abstract interface private subroutine set_multiple_sub (this, elements, items) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: elements The indices (starting from 1) of the elements whose values \n are to be set. class(*), intent(in), dimension(:) :: items The values to be stored in the specified elements. Each item\n is placed in the element specified by the integer in the\n corresponding position in the array elements . abstract interface private subroutine foreach_sub (this, action) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( action_sub ) :: action A procedure to act on each element of the list abstract interface private subroutine insert_sub (this, position, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: position The location at which the new element will be placed class(*), intent(in) :: item The value to be placed in the list abstract interface private subroutine remove_sub (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the first occurrence of which will be removed from\n the list abstract interface private subroutine remove_last_sub (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, the last occurrence of which will be removed from\n the list abstract interface private subroutine remove_all_sub (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this class(*), intent(in) :: item An item, all occurrences of which will be removed from the\n list abstract interface private subroutine delete_single_sub (this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: element The position of the element to be deleted from the list abstract interface private subroutine delete_multiple_sub (this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in), dimension(:) :: element The positions of the elements to be deleted from the list abstract interface private subroutine delete_slice_sub (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this integer, intent(in) :: start_element Index of the first element in the slice to be deleted integer, intent(in) :: end_element Index of the last element in the slice to be deleted abstract interface private subroutine sort_sub (this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(inout) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another abstract interface private pure function get_func (this, element) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: element The index (starting from 1) of the element to return Return Value class( container ),\n  allocatable The item with index element abstract interface private pure function get_index_func (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the first occurrence of item in list abstract interface private pure function get_last_index_func (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer Position of the last occurrence of item in list abstract interface private pure function get_indices_func (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item Return Value integer,\n  dimension(:),allocatable Positions of the all occurrences of item in list abstract interface private function slice_func (this, start_element, end_element) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this integer, intent(in) :: start_element The index of the first element in the slice to be returned integer, intent(in) :: end_element The index of the last element in the slice to be returned Return Value class( list ),\n  allocatable A list containing the elements within the slice. abstract interface private elemental function has_func (this, item) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item A value whose presence in the list is being checked for Return Value logical .true. if item is present in list, .false. otherwise abstract interface private pure function min_func (this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The smallest item in the list, as determined by the comparison function abstract interface private pure function max_func (this, comparison) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( comparison_func ) :: comparison A procedure which evaluates whether a container object is\n less than, equal to, or greater than another Return Value class( container ),\n  allocatable The largest item in the list, as determined by the comparison function abstract interface private pure function nearest_func (this, item, subtraction) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this class(*), intent(in) :: item The value which those in the list are being compared to procedure( subtraction_func ) :: subtraction A function determining the magnitude of the difference\n between two items Return Value class( container ),\n  allocatable The value from the list which, when passed to subtraction with item as the other argument, returns the smallest value abstract interface private pure function sum_func (this, addition) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( addition_func ) :: addition A procedure performing addition between two container objects and returning the result in another container Return Value class( container ),\n  allocatable A container holding the sum of all of the items held within\n this list abstract interface private pure function filter_func (this, test) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this procedure( test_func ) :: test A test for which the values that pass will be returned in a\n new list Return Value class( list ),\n  allocatable Contains those items in this list for which test returns .true. abstract interface private pure function to_array_func (this) Arguments Type Intent Optional Attributes Name class( list ), intent(in) :: this Return Value class( container ),\n  dimension(:),allocatable An array of container objects holding the contents of\n this list Derived Types type, public, abstract, extends( deque ) :: list Type-Bound Procedures procedure(append_sub), public, deferred :: append Add an item to the end of the list procedure(get_func), public, deferred :: get Get the item at the specified index procedure(set_single_sub), private, deferred :: set_single Set the specified element to the specified value procedure(set_multiple_sub), private, deferred :: set_multiple Set the specified elements to the specified values generic, public :: set => set_single, set_multiple Set the value of one or more elements in the list procedure(get_index_func), public, deferred :: get_index Get the index of the first occurrence of this item in the list procedure(get_last_index_func), public, deferred :: get_last_index Get the index of the last occurrence of this item in the list procedure(get_indices_func), public, deferred :: get_indices Get the indices of all occurrences of this item in the list procedure(slice_func), public, deferred :: slice Returns a list containing the items with indices in the\n specified range procedure(foreach_sub), public, deferred :: foreach Perform the provided procedure on each element of the list procedure(insert_sub), public, deferred :: insert Add the item to the specified position in the list, moving\n all succeeding elements forward by one position procedure(remove_sub), public, deferred :: remove Remove the first occurrence of the specified item from the list procedure(remove_last_sub), public, deferred :: remove_last Remove the last occurrence of the specified item from the list procedure(remove_all_sub), public, deferred :: remove_all Remove the all occurrences of the specified item from the list procedure(delete_single_sub), private, deferred :: delete_single Remove the item from the list at the specified index procedure(delete_multiple_sub), private, deferred :: delete_multiple Remove the items from the list at the specified indices procedure(delete_slice_sub), private, deferred :: delete_slice Remove the items from the list within the specified slice generic, public :: delete => delete_single, delete_multiple, delete_slice Remove one or more elements from the list procedure(has_func), public, deferred :: has Returns .true. if the specified item is present in the list. procedure(sort_sub), public, deferred :: sort Sorts the list in place using the provided comparison procedure procedure(min_func), public, deferred :: min Returns the smallest item in the list as determined using the\n provided comparison procedure procedure(max_func), public, deferred :: max Returns the largest item in the list as determined using the\n provided comparison procedure procedure(nearest_func), public, deferred :: nearest Returns the item in the list for which the provided subtraction\n procedure returns the smallest absolute value procedure(sum_func), public, deferred :: sum Returns an item representing the sum as determined by\n iteratively applying the provided addition procedure to all\n elements in the list procedure(filter_func), public, deferred :: filter Returns a list containing all elements from this list for which\n the provided test procedure returns .true. procedure(to_array_func), public, deferred :: to_array Returns an array of containers holding the contents of this\n list. Description An abstract data type representing a list. This is a fully dynamic\n means of storing data of a single type and comes with many advanced\n type-bound procedures for manipulating said data. This derived type\n aims to provide many of the same features found in lists in \n higher-level languages such as Python","tags":"","loc":"module/list_mod.html","title":"list_mod – FIAT"},{"text":"Uses: abstract_container_mod dictionary_mod module~~map_mod~~UsesGraph module~map_mod map_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~map_mod module~dictionary_mod dictionary_mod module~abstract_container_mod->module~dictionary_mod module~array_list_mod array_list_mod module~abstract_container_mod->module~array_list_mod module~data_set_mod data_set_mod module~abstract_container_mod->module~data_set_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~ordered_mod ordered_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~dictionary_mod->module~map_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod module~array_list_mod->module~dictionary_mod module~array_list_mod->module~data_set_mod module~data_set_mod->module~dictionary_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod module~countable_mod countable_mod module~countable_mod->module~data_set_mod module~countable_mod->module~ordered_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod var panmodulemap_modUsesGraph = svgPanZoom('#modulemap_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for a standard map data structures. These \n are data structures which consist of key-value pairs, with only one\n value per key. It is similar to the dictionary type in Python. Used By module~~map_mod~~UsedByGraph module~map_mod map_mod module~multimap_mod multimap_mod module~map_mod->module~multimap_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure subroutine update_sub (this, other) Arguments Type Intent Optional Attributes Name class( map ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n overwriting as necessary. abstract interface private pure function get_func (this, key) Arguments Type Intent Optional Attributes Name class( map ), intent(in) :: this class(*), intent(in) :: key The key whose associated value is to be returned Return Value class( container ),\n  allocatable The value associated with the specified key Derived Types type, public, abstract, extends( dictionary ) :: map Type-Bound Procedures procedure(get_func), public, deferred :: get Returns the value associated with the specified key. procedure(update_sub), public, deferred :: update Adds any key-value pairs in the second map not already present.\n Updates the value for all keys in this dictionary also present \n in the second dictionary. Description An abstract type for the standard map data structures. These are \n data structures which consist of key-value pairs, with only one \n value per key. It has similar functionality to the dictionary type in Python.","tags":"","loc":"module/map_mod.html","title":"map_mod – FIAT"},{"text":"Uses: dictionary_mod array_list_mod map_mod module~~multimap_mod~~UsesGraph module~multimap_mod multimap_mod module~array_list_mod array_list_mod module~array_list_mod->module~multimap_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~map_mod->module~multimap_mod module~list_mod list_mod module~list_mod->module~array_list_mod module~ordered_mod ordered_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~array_list_mod module~abstract_container_mod->module~dictionary_mod module~abstract_container_mod->module~map_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~ordered_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~iterable_mod iterable_mod module~abstract_container_mod->module~iterable_mod module~abstract_container_mod->module~data_set_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod module~iterator_mod->module~iterable_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~countable_mod->module~data_set_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod module~data_set_mod->module~dictionary_mod var panmodulemultimap_modUsesGraph = svgPanZoom('#modulemultimap_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for a multiple map data structure. These \n are data structures which consist of key-value pairs, potentially\n holding multiple values per key. Abstract Interfaces abstract interface private pure subroutine update_multimap_sub (this, other) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( multimap ), intent(in) :: other A multimap whose key-value pairs will be added to this one,\n adding values to any keys which already exist in this one. abstract interface private pure subroutine update_map_sub (this, other) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class( map ), intent(in) :: other A map whose key-value pairs will be added to this one,\n appending the value to any keys which already exist in this\n one. abstract interface private pure subroutine remove_val_sub (this, key, val) Arguments Type Intent Optional Attributes Name class( multimap ), intent(inout) :: this class(*), intent(in) :: key A key from which to remove a value class(*), intent(in) :: val A value which will be removed from key , if key has such\n a value. abstract interface private pure function get_func (this, key) Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be returned Return Value type( array_list ) The values associated with the specified key abstract interface private pure function get_count_func (this, key) Arguments Type Intent Optional Attributes Name class( multimap ), intent(in) :: this class(*), intent(in) :: key The key whose associated values are to be counted Return Value real Derived Types type, public, abstract, extends( dictionary ) :: multimap Type-Bound Procedures procedure(get_func), public, deferred :: get Returns a list of values associated with the specified key. procedure(get_count_func), public, deferred :: get_count Returns the number of values associated with the specified key. procedure(update_map_sub), private, deferred :: update_map Adds any key-value pairs in the standard map to this one. If a\n key does not already exist in this dictionary then it is \n created and assigned the corresponding value. Otherwise, the\n value in the other dictionary is just added to the values \n associated with the key in this one. procedure(update_multimap_sub), private, deferred :: update_multimap Adds any key-value pairs in the second multipmap to this one.\n If a key does not already exist in this dictionary then it is\n created and assigned the corresponding values. Otherwise, the\n values in the other dictionary add just added to the values \n associated with the key in this one. generic, public :: update => update_map, update_multimap Update this multimap's contents with those of another \n (multi)map procedure(remove_val_sub), public, deferred :: remove_value Remove the specified value from the specified key Description An abstract type for the standard map data structures. These are \n data structures which consist of key-value pairs, potentially \n holding multiple values per key.","tags":"","loc":"module/multimap_mod.html","title":"multimap_mod – FIAT"},{"text":"Uses: dynamic_set_mod module~~multiset_mod~~UsesGraph module~multiset_mod multiset_mod module~dynamic_set_mod dynamic_set_mod module~dynamic_set_mod->module~multiset_mod module~iterable_mod iterable_mod module~iterable_mod->module~dynamic_set_mod module~countable_mod countable_mod module~iterable_mod->module~countable_mod module~ordered_mod ordered_mod module~iterable_mod->module~ordered_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~dynamic_set_mod module~abstract_container_mod->module~iterable_mod module~data_set_mod data_set_mod module~abstract_container_mod->module~data_set_mod module~iterator_mod iterator_mod module~abstract_container_mod->module~iterator_mod module~array_list_mod array_list_mod module~abstract_container_mod->module~array_list_mod module~list_mod list_mod module~abstract_container_mod->module~list_mod module~abstract_container_mod->module~ordered_mod module~deque_mod deque_mod module~abstract_container_mod->module~deque_mod module~data_set_mod->module~dynamic_set_mod module~iterator_mod->module~iterable_mod module~iterator_mod->module~array_list_mod module~iterator_mod->module~ordered_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod module~countable_mod->module~data_set_mod module~countable_mod->module~ordered_mod module~array_list_mod->module~data_set_mod module~list_mod->module~array_list_mod module~ordered_mod->module~array_list_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~deque_mod->module~list_mod module~queue_mod->module~deque_mod var panmodulemultiset_modUsesGraph = svgPanZoom('#modulemultiset_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract type for a multi-set data structure. These \n behave like a normal set, except they keep count of the number of\n times which an item has been added. Abstract Interfaces abstract interface private pure function get_func (this, item) Arguments Type Intent Optional Attributes Name class( multiset ), intent(in) :: this class(*), intent(in) :: item The item whose presence in the set is being checked Return Value integer The number of times this item appears in the set Derived Types type, public, abstract, extends( dynamic_set ) :: multiset Type-Bound Procedures procedure(get_func), public, deferred :: get Returns the number of times this item is present in the set. Description Provides an abstract type for a multi-set data structure. These \n behave like a normal set, except they keep count of the number of\n times which an item has been added. When an item is removed, the\n count will be decremented by 1. The item will only become absent\n from the list ( has returns .false. ) when the count\n reaches zero.","tags":"","loc":"module/multiset_mod.html","title":"multiset_mod – FIAT"},{"text":"Uses: abstract_container_mod module~~node_mod~~UsesGraph module~node_mod node_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~node_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides a node data type, for holding some sort of contents.\n While a node itself is unlikely to be very useful, various type\n extensions are also made which are then used to build more complex\n data structures. It is not anticipated that the node type, or any types extending it,\n will be handled directly by end users of FIAT; they are meant for\n internal use within this package. Used By module~~node_mod~~UsedByGraph module~node_mod node_mod module~linked_node_mod linked_node_mod module~node_mod->module~linked_node_mod module~bidir_node_mod bidir_node_mod module~linked_node_mod->module~bidir_node_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public :: node Components Type Visibility Attributes Name Initial class( container ), private, allocatable :: contents Contains the value held in this node. Type-Bound Procedures procedure, public, non_overridable :: has_contents Evaluates whether contents have been assigned to node. procedure, public, non_overridable :: get_contents Returns the value stored in the node. procedure, public, non_overridable :: set_contents Sets the value to be stored in the node. procedure, public, non_overridable :: unset_contents Removes the record of any value stored in the node. Description An object which contains a container that can be set to have\n arbitrary contents. While of limited use on its own, various\n derived types exist which are extensions of this one exist and\n are used to build more complex data structures. Functions private elemental function has_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value logical Description Author Chris MacMackin Date February 2016 Returns whether or not a values has been assigned to the node. private pure function get_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(in) :: this Return Value class( container ),\n  allocatable The stored in the node. Description Author Chris MacMackin Date February 2016 An accessor returning a container object storing the value\n placed in the node. If the contents have not been set then an\n unallocated container is returned. Subroutines private subroutine set_contents (this, contents) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this class( container ), intent(inout), allocatable :: contents The new value to be stored in this node. The actual argument\n will be deallocated during the process of assigning it to the\n node. Description Author Chris MacMackin Date February 2016 Places a new value into storage within the node. This value must\n already be heald within an allocatable container . The actual\n argument will be deallocated after the subroutine call, as its\n allocation is moved to the contents of the node. private subroutine unset_contents (this) Arguments Type Intent Optional Attributes Name class( node ), intent(inout) :: this Description Author Chris MacMackin Date February 2016 Deallocates the value stored within the  node.","tags":"","loc":"module/node_mod.html","title":"node_mod – FIAT"},{"text":"Uses: iterator_mod iterable_mod countable_mod abstract_container_mod module~~ordered_mod~~UsesGraph module~ordered_mod ordered_mod module~iterator_mod iterator_mod module~iterator_mod->module~ordered_mod module~iterable_mod iterable_mod module~iterator_mod->module~iterable_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~ordered_mod module~abstract_container_mod->module~iterator_mod module~abstract_container_mod->module~iterable_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmoduleordered_modUsesGraph = svgPanZoom('#moduleordered_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides the ordered abstract type. This is a data structure for\n which the order of the elements is known. One of the effects of this\n is that order in which items are retrieved is determined by the \n order in which they are added to the data structure. Used By module~~ordered_mod~~UsedByGraph module~ordered_mod ordered_mod module~queue_mod queue_mod module~ordered_mod->module~queue_mod module~array_list_mod array_list_mod module~ordered_mod->module~array_list_mod module~deque_mod deque_mod module~queue_mod->module~deque_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~list_mod list_mod module~deque_mod->module~list_mod module~list_mod->module~array_list_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod var panmoduleordered_modUsedByGraph = svgPanZoom('#moduleordered_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private pure subroutine push_sub (this, item) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in) :: item Contents to be added to this data structure abstract interface private pure subroutine blank_sub (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this abstract interface private function pop_func (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this Return Value class( container ),\n  allocatable The next item in the data structure, which has been removed abstract interface private pure function peek_func (this) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: this Return Value class( container ),\n  allocatable The next item in the data structure abstract interface private pure function logical_return () Arguments None Return Value logical True if first in first out structure, false if last in \n first out abstract interface private pure function concat_func (lhs, rhs) Arguments Type Intent Optional Attributes Name class( ordered ), intent(in) :: lhs This object class( ordered ), intent(in) :: rhs The object being concatenated to this one Return Value class( ordered ),\n  allocatable The result of the concatenation Derived Types type, public, abstract, extends( countable ) :: ordered Type-Bound Procedures procedure(push_sub), public, deferred :: push Place a new item in the data structure procedure(pop_func), public, deferred :: pop Remove and return the next item from the data structure procedure(peek_func), public, deferred :: peek Return, but do not remove, the next item in the data structure procedure(blank_sub), public, deferred :: clear Remove all contents from the data structure procedure(logical_return), public, nopass, deferred :: is_fifo Indicates whether this is a first in first out or last in last\n out data type. procedure, private :: array_extend Add ( push ) the elements of an array to this data\n structure procedure, private :: iterator_extend Add ([[ordered::push]]) the contents of an iterator to \n this data structure. generic, public :: extend => array_extend, iterator_extend Place multiple new items in the data structure procedure(concat_func), private, deferred :: concat Join this object with another ordered object, returning\n the result. The contents of the returned object are ordered\n such that applying pop until the structure is\n empty would provide items in the same order as calling pop until the first object is empty and then until\n the second object is empty. generic, public :: operator(//) => concat Overloads the concatenation operator to join this object with\n another ordered object, returning the result. The contents\n of the returned object are ordered such that applying pop until the structure is empty would provide \n items in the same order as calling pop until the \n first object is empty and then until the second object is \n empty. Description An abstract type which is an ancestor for any data structure in\n which items are stored in a particular order. This means that \n the order in which items are placed in the structure will \n determine the order in which they are retrieved. Examples of data\n structures descending from this one are a [[stack]], queue , or list . Subroutines private subroutine array_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class(*), intent(in), dimension(:) :: items The items to be added to this data structure Description Author Chris MacMackin Date February 2016 Adds the elements of an array to this object. private subroutine iterator_extend (this, items) Arguments Type Intent Optional Attributes Name class( ordered ), intent(inout) :: this class( iterable ), intent(inout) :: items The iterable whose contents are to be added to this data\n structure. Description Author Chris MacMackin Date February 2016 Adds the contents of an iterable object to this data structure.","tags":"","loc":"module/ordered_mod.html","title":"ordered_mod – FIAT"},{"text":"Uses: ordered_mod module~~queue_mod~~UsesGraph module~queue_mod queue_mod module~ordered_mod ordered_mod module~ordered_mod->module~queue_mod module~iterator_mod iterator_mod module~iterator_mod->module~ordered_mod module~iterable_mod iterable_mod module~iterator_mod->module~iterable_mod module~countable_mod countable_mod module~countable_mod->module~ordered_mod module~abstract_container_mod abstract_container_mod module~abstract_container_mod->module~ordered_mod module~abstract_container_mod->module~iterator_mod module~abstract_container_mod->module~iterable_mod module~iterable_mod->module~ordered_mod module~iterable_mod->module~countable_mod iso_fortran_env iso_fortran_env iso_fortran_env->module~abstract_container_mod var panmodulequeue_modUsesGraph = svgPanZoom('#modulequeue_modUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Provides an abstract data type representing a queue (first in first \n out) data structure. Used By module~~queue_mod~~UsedByGraph module~queue_mod queue_mod module~deque_mod deque_mod module~queue_mod->module~deque_mod module~list_mod list_mod module~deque_mod->module~list_mod module~array_list_mod array_list_mod module~list_mod->module~array_list_mod module~multimap_mod multimap_mod module~array_list_mod->module~multimap_mod module~data_set_mod data_set_mod module~array_list_mod->module~data_set_mod module~dictionary_mod dictionary_mod module~array_list_mod->module~dictionary_mod module~data_set_mod->module~dictionary_mod module~dynamic_set_mod dynamic_set_mod module~data_set_mod->module~dynamic_set_mod module~dictionary_mod->module~multimap_mod module~map_mod map_mod module~dictionary_mod->module~map_mod module~multiset_mod multiset_mod module~dynamic_set_mod->module~multiset_mod module~map_mod->module~multimap_mod var panmodulequeue_modUsedByGraph = svgPanZoom('#modulequeue_modUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, abstract, extends( ordered ) :: queue Type-Bound Procedures procedure, public, nopass :: is_fifo => queue_is_fifo Returns true, as queues are a first in first out data type. Description An abstract data type representing the queue structure. This is \n largely a placeholder type, in case some methods specific to queues\n are added at a later time. However, it does implement the is_fifo method. Functions private pure function queue_is_fifo () Arguments None Return Value logical Description Author Chris MacMackin Date February 2016 Returns .true. , indicating that queues are a \"first in first \n out\" data structure.","tags":"","loc":"module/queue_mod.html","title":"queue_mod – FIAT"}]}